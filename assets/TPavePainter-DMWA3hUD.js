import{O as vt,bg as yt,bh as _t,n as u,bi as Yt,L as W,Y as E,bj as V,i as Z,B as Ot,m as tt,bk as nt,bl as rt,U as et,aW as it,bm as ct,bn as ut,bo as Dt,bp as Xt,K as U,bq as j,d as ft,br as Ft,bs as Lt,a0 as At,a6 as pt,u as kt,E as Nt,aH as Rt,am as q,aS as Bt,N as xt,bt as Ht,bu as Et,S as Tt,bv as It,k as Mt,e as Gt,az as Wt,bw as Vt,b2 as Zt}from"./index-DAa9yKAB.js";const $t=Ot(17),Ut="postitle",Pt="autoplace",wt="brNDC";function jt(at){const e=(t,i)=>Math.abs(t-i)<.001;return e(at.fX1NDC,u.fStatX-u.fStatW)&&e(at.fY1NDC,u.fStatY-u.fStatH)&&e(at.fX2NDC,u.fStatX)&&e(at.fY2NDC,u.fStatY)}class bt extends vt{#i;#a;#e;#t;#n;#r;#s;constructor(e,t,i){super(e,t,i),this.Enabled=!0,this.UseContextMenu=!0}async autoPlaceLegend(e,t,i){let r=this.getPadPainter().getFrameSvg().selectChild(".main_layer").node().outerHTML;r=yt(r),r=`<svg xmlns="${_t}"`+r.slice(4);const n=t?.fLeftMargin??u.fPadLeftMargin,l=t?.fRightMargin??u.fPadRightMargin,h=t?.fTopMargin??u.fPadTopMargin,a=t?.fBottomMargin??u.fPadBottomMargin;return Yt(r).then(s=>{if(!s)return!1;let d=100,p=100;const x=s.getContext("2d"),c=x.getImageData(0,0,s.width,s.height).data,S=Math.floor(s.width/d),$=Math.floor(s.height/p),w=new Array(d*p);c.length!==s.width*s.height*4&&(console.log(`Image size missmatch in TLegend autoplace ${c.length} expected ${s.width*s.height*4}`),d=p=0);for(let o=0;o<d;++o){const P=o*S,g=P+S;for(let D=0;D<p;++D){const b=D*$,N=b+$;let v=0;for(let L=P;L<g&&!v;++L)for(let M=b;M<N;++M){const C=(M*s.width+L)*4;if(c[C]||c[C+1]||c[C+2]||c[C+3]){v=1;break}}w[D*d+o]=v}}const m=.3/Math.max(.2,1-n-l),T=Math.min(.5,Math.max(.1,e.fPrimitives.arr.length*.05))/Math.max(.2,1-h-a),Y=Math.round(m*d),O=Math.round(T*p),z=(o,P)=>{for(let g=o;g<o+Y;++g)for(let D=P;D<P+O;++D)if(w[D*d+g])return!1;return!0};for(let o=0;o<d-Y;++o)for(let P=p-O-1;P>=0;--P)if(z(o,P))return e.fX1NDC=n+o/d*(1-n-l),e.fX2NDC=e.fX1NDC+m*(1-n-l),e.fY2NDC=1-h-P/p*(1-a-h),e.fY1NDC=e.fY2NDC-T*(1-a-h),!0}).then(s=>{if(s||i)return s;e.fX1NDC=Math.max(n??0,e.fX2NDC-.3),e.fX2NDC=Math.min(e.fX1NDC+.3,1-l);const d=Math.max(e.fPrimitives?e.fPrimitives.arr.length*.05:0,.2);return e.fY2NDC=Math.min(1-h,e.fY1NDC+d),e.fY1NDC=Math.max(e.fY2NDC-d,a),!0})}getPaveDrawOption(){let e=this.getDrawOpt();return(this.isStats()||!e)&&(e=this.getObject()?.fOption),e||wt}setPaveDrawOption(e){this.isStats()?this.getObject().fOption=e:this.storeDrawOpt(e)}async drawPave(e){if(!this.Enabled)return this.removeG(),this;const t=this.getObject(),i=this.getPaveDrawOption().toUpperCase(),f=this.getFramePainter(),r=this.getPadPainter(),n=r.getRootPad(!0);let l,h,a;t.fInit===0&&(this.stored=Object.assign({},t),t.fInit=1,t._typename===W&&!t.fX1&&!t.fX2&&!t.fY1&&!t.fY2?f?(t.fX1NDC=f.fX2NDC+.01,t.fX2NDC=Math.min(.96,f.fX2NDC+.06),t.fY1NDC=f.fY1NDC,t.fY2NDC=f.fY2NDC):(t.fX2NDC=.8,t.fX1NDC=.9,t.fY1NDC=.1,t.fY2NDC=.9):t.fOption.indexOf("NDC")>=0?(t.fX1NDC<1e-20&&t.fX2NDC<1e-20&&(t.fX1NDC=t.fX1,t.fX2NDC=t.fX2),t.fY1NDC<1e-20&&t.fY2NDC<1e-20&&(t.fY1NDC=t.fY1,t.fY2NDC=t.fY2)):n&&n.fX1===0&&n.fX2===1&&n.fY1===0&&n.fY2===1&&E(e)&&e.indexOf("postpone")>=0?(t.fInit=0,t.fX1NDC=t.fY1NDC=.99,t.fX2NDC=t.fY2NDC=1):n?(n.fLogx&&(t.fX1>0&&(t.fX1=Math.log10(t.fX1)),t.fX2>0&&(t.fX2=Math.log10(t.fX2))),n.fLogy&&(t.fY1>0&&(t.fY1=Math.log10(t.fY1)),t.fY2>0&&(t.fY2=Math.log10(t.fY2))),t.fX1NDC=(t.fX1-n.fX1)/(n.fX2-n.fX1),t.fY1NDC=(t.fY1-n.fY1)/(n.fY2-n.fY1),t.fX2NDC=(t.fX2-n.fX1)/(n.fX2-n.fX1),t.fY2NDC=(t.fY2-n.fY1)/(n.fY2-n.fY1)):(t.fX1NDC=t.fY1NDC=.1,t.fX2NDC=t.fY2NDC=.9));let s=Promise.resolve(!0);return t._typename===V&&(this.AutoPlace||t.fX1NDC===t.fX2NDC&&t.fY1NDC===t.fY2NDC)&&(s=this.autoPlaceLegend(t,n).then(d=>(delete this.AutoPlace,d||(t.fX1NDC=f.fX2NDC-.2,t.fX2NDC=f.fX2NDC,t.fY1NDC=f.fY2NDC-.1,t.fY2NDC=f.fY2NDC),d))),s.then(()=>{if(this.isStats()&&!this.NoFillStats&&!r.isFastDrawing()){const m=t.$main_painter||this.getMainPainter();if(Z(m?.fillStatistic)){let T=t.fOptStat,Y=t.fOptFit;if((t.TestBit($t)||!Number.isInteger(T))&&(T=u.fOptStat),(t.TestBit($t)||!Number.isInteger(Y))&&(Y=u.fOptFit),m.fillStatistic(this,T,Y)){let O=t.fLines?.arr.length||0;const z=O>0&&!this.moved_interactive&&jt(t),o=this.#n&&this.#r>1?u.fStatH:0;o&&(O-=this.#s);let P=u.fStatH,g=u.fStatW;this.#n&&(g=1.8*u.fStatW),u.fStatFontSize<=0||u.fStatFont%10===3?P=O*.25*u.fStatH:u.fStatFontSize<1&&(P=O*u.fStatFontSize),z?(t.fX1NDC=Math.max(.005,t.fX2NDC-g),t.fY1NDC=Math.max(.005,t.fY2NDC-P-o)):(t.fY1NDC>t.fY2NDC&&(t.fY2NDC=Math.min(.995,t.fY1NDC+P+o)),t.fX1NDC>t.fX2NDC&&(t.fY2NDC=Math.min(.995,t.fX1NDC+g)))}}}const d=r.getPadRect(),p=t.fBorderSize,x=i.indexOf("NB")>=0,c=i.indexOf("L")>=0?-1:i.indexOf("R")>=0?1:0,S=i.indexOf("T")>=0?-1:i.indexOf("B")>=0?1:0,$=this.createG();this.#i=Math.round(t.fX1NDC*d.width),this.#a=Math.round((1-t.fY2NDC)*d.height),h=Math.round((t.fX2NDC-t.fX1NDC)*d.width),a=Math.round((t.fY2NDC-t.fY1NDC)*d.height);const w=i.indexOf("ARC")>=0&&t.fCornerRadius>0?Math.round(Math.min(h,a)*t.fCornerRadius):0;if(tt($,this.#i,this.#a),this.createAttLine({attr:t,width:p>0?t.fLineWidth:0}),this.createAttFill({attr:t}),this.fillatt.empty()&&w&&this.fillatt.setSolidColor(this.getColor(t.fFillColor)||"white"),t._typename===nt){const m=Math.round(a/2),T=Math.round(h/2),Y=`l${T},${-m}l${T},${m}l${-T},${m}z`;this.fillatt.empty()||this.drawBorder($,h,a,0,Y),l=$.append("svg:path").attr("d","M0,"+m+Y).call(this.fillatt.func).call(this.lineatt.func);const O=$.append("svg:g");return tt(O,Math.round(h/4),Math.round(a/4)),this.drawPaveText(T,m,e,O)}if(t.fNpaves)for(let m=t.fNpaves-1;m>0;--m)$.append("svg:path").attr("d",`M${c*4*m},${S*4*m}h${h}v${a}h${-h}z`).call(this.fillatt.func).call(this.lineatt.func);else this.drawBorder($,h,a,w);switch((!this.isBatchMode()||!this.fillatt.empty()||!this.lineatt.empty()&&!x)&&(w?l=$.append("svg:rect").attr("width",h).attr("height",a).attr("rx",w):l=$.append("svg:path").attr("d",`M0,0H${h}V${a}H0Z`),l.call(this.fillatt.func),x||l.call(this.lineatt.func)),t._typename){case ut:case ct:return this.drawPaveLabel(h,a,e);case it:return this.drawPaveStats(h,a,e);case et:case rt:case nt:return this.drawPaveText(h,a,e);case V:return this.drawLegend(h,a,e);case W:return this.drawPaletteAxis(h,a,e)}}).then(()=>this.isBatchMode()||t._typename===Dt?this:(l?.style("pointer-events","visibleFill").on("mouseenter",()=>this.showObjectStatus()),Xt(this,{obj:t,x:this.#i,y:this.#a,width:h,height:a,minwidth:10,minheight:20,canselect:!0,ctxmenu:Vt.touches&&U.ContextMenu&&this.UseContextMenu,redraw:()=>{this.moved_interactive=!0,this.interactiveRedraw(!1,"pave_moved").then(()=>this.drawPave())}}),this.UseContextMenu&&U.ContextMenu&&this.getG().on("contextmenu",d=>this.paveContextMenu(d)),this.isPalette()&&this.interactivePaletteAxis(h,a),this))}drawBorder(e,t,i,f,r){const n=this.getObject(),l=this.getPaveDrawOption().toUpperCase().replaceAll("ARC","").replaceAll("NDC",""),h=this.isPalette()||l.indexOf("NB")>=0,a=l.indexOf("L")>=0?-1:l.indexOf("R")>=0?1:0,s=l.indexOf("T")>=0?-1:l.indexOf("B")>=0?1:0;if(n.fBorderSize<2||n.fShadowColor===0||!a&&!s||h)return;const d=this.getColor(n.fShadowColor),p=n.fBorderSize,x=!this.lineatt.empty()&&this.lineatt.width>2?`${this.lineatt.width-1}px`:"1px";if(r)e.append("svg:path").attr("d",`M0,${Math.round(i/2)+p}${r}`).style("fill",d).style("stroke",d).style("stroke-width",x);else if(f)e.append("svg:rect").attr("width",t).attr("height",i).attr("rx",f).attr("x",a*p).attr("y",s*p).style("fill",d).style("stroke",d).style("stroke-width",x);else{let c;a<0&&s<0?c=`M0,0v${i-p-1}h${1-p}v${2-i}h${t-2}v${p-1}z`:a<0&&s>0?c=`M0,${i}v${p+1-i}h${1-p}v${i-2}h${t-2}v${1-p}z`:a>0&&s<0?c=`M${p+1},0v${1-p}h${t-2}v${i-2}h${1-p}v${p+1-i}z`:c=`M${t},${p+1}h${p-1}v${i-2}h${2-t}v${1-p}h${t-p-2}z`,e.append("svg:path").attr("d",c).style("fill",d).style("stroke",d).style("stroke-width",x)}}fillWebObjectOptions(e){const t=this.getObject();return t?.fInit&&(e.fcust="pave",e.fopt=[t.fX1NDC,t.fY1NDC,t.fX2NDC,t.fY2NDC],t.fName==="stats"&&this.isStats()&&t.fLines.arr.forEach(i=>{(i._typename===j||i._typename===ft)&&(e.fcust+=`;;${i.fTitle}`)})),e}async drawPaveLabel(e,t){const i=this.getObject();return!i.fLabel||!i.fLabel.trim()?this:(this.createAttText({attr:i,can_rotate:!1}),this.startTextDrawingAsync(this.textatt.font,t/1.2).then(()=>this.drawText(this.textatt.createArg({width:e,height:t,text:i.fLabel,norotate:!0}))).then(()=>this.finishTextDrawing()))}drawPaveStats(e,t){const i=this.getObject(),f=[],r=[];let n=0,l=0,h=0;for(let x=0;x<i.fLines.arr.length;++x){const c=i.fLines.arr[x];(c._typename===j||c._typename===ft)&&(f.push(c.fTitle),r.push(c.fTextColor))}const a=f.length;for(let x=0;x<a;++x){const c=f[x];if(x>0&&(h=Math.max(h,c.length)),x===0||c.indexOf("|")<0)continue;n===0&&(n=x);const S=c.split("|");S.length>l&&(l=S.length)}const s=t/a,d=i.fMargin*e;let p=!1;return this.createAttText({attr:i,can_rotate:!1}),this.startTextDrawingAsync(this.textatt.font,t/(a*1.2)).then(()=>{if(a===1)this.drawText(this.textatt.createArg({width:e,height:t,text:f[0],latex:1,norotate:!0}));else for(let c=0;c<a;++c){const S=c*s,$=r[c]>1?this.getColor(r[c]):this.textatt.color;if(n&&c>=n){const w=f[c].split("|");for(let m=0;m<w.length;++m)this.drawText({align:"middle",x:e*m/l,y:S,latex:0,width:e/l,height:s,text:w[m],color:$})}else if(f[c].indexOf("=")<0){if(c===0){p=!0;const w=Math.max(h,Math.round((e-2*d)/s/.65));f[c].length>w+5&&(f[c]=f[c].slice(0,w+2)+"...")}this.drawText({align:c===0?"middle":"start",x:d,y:S,width:e-2*d,height:s,text:f[c],color:$})}else{const w=f[c].split("="),m=[];for(let T=0;T<2;++T){const Y={align:T===0?"start":"end",x:d,y:S,width:e-2*d,height:s,text:T>0?w[T].trimStart():w[T].trimEnd(),color:$,_expected_width:e-2*d,_args:m,post_process(O){this._args[0].ready&&this._args[1].ready&&O.scaleTextDrawing(1.05*(this._args[0].result_width+this._args[1].result_width)/this._expected_width,O.getG())}};m.push(Y)}for(let T=0;T<2;++T)this.drawText(m[T])}}let x="";if(i.fBorderSize>0&&p&&(x+=`M0,${Math.round(s)}h${e}`),n>0&&l>1){for(let c=n;c<a;++c)x+=`M0,${Math.round(c*s)}h${e}`;for(let c=0;c<l-1;++c)x+=`M${Math.round(e/l*(c+1))},${Math.round(n*s)}V${t}`}return x&&this.appendPath(x).call(this.lineatt.func),this.finishTextDrawing(void 0,a>1)})}async drawPaveText(e,t,i,f){const r=this.getObject(),n=r.fLines?.arr||[],l=n.length,h=this.getPadPainter(),a=h.getPadHeight(),s=r.fLabel.length,d=[],p=r.fMargin*e,x=t/(l||1),c=.85*x;let S=0;this.createAttText({attr:r,can_rotate:!1}),l===1&&this.textatt.size>0&&(S=Math.max(3,this.textatt.getSize(h))),f||(f=this.getG());const $=l===1&&h.isFastDrawing();let w=0,m=0,T=0,Y=0;return n.forEach(z=>{z._typename!==j&&z._typename!==ft||!z.fTitle?.trim()||(w++,(z.fX||z.fY||z.fTextSize)&&m++,!z.fTextSize&&!this.textatt.size&&(T=Math.max(T,Ft(z.fTitle,this.textatt.font,c))))}),T&&(Y=c,T>.92*e&&(Y*=.92*e/T),Y=Math.round(Y)),(w>m?this.startTextDrawingAsync(this.textatt.font,this.$postitle?this.textatt.getSize(h,1,.05):c,f,S):Promise.resolve()).then(()=>{for(let z=0;z<l;++z){const o=n[z],P=z*x;switch(o._typename){case j:case ft:{if(!o.fTitle||!o.fTitle.trim())continue;let g=o.fTextColor?this.getColor(o.fTextColor):"";g||(g=this.textatt.color);const D=o.fTextAlign||this.textatt.align,b=D%10,N=(D-b)/10;if(o.fX||o.fY||o.fTextSize){const v=o.fX?o.fX*e:N===1?p:N===2?e/2:e-p,L=o.fY?(1-o.fY)*t:P+(b===2?x/2:b===3?x:0),M=f.append("svg:g");d.push(this.startTextDrawingAsync(this.textatt.font,this.textatt.getAltSize(o.fTextSize,h)||Y,M).then(()=>this.drawText({align:D,x:v,y:L,text:o.fTitle,color:g,latex:o._typename===j?0:1,draw_g:M,fast:$})).then(()=>this.finishTextDrawing(M)))}else{const v={x:0,y:P,draw_g:f,latex:o._typename===j?0:1,text:o.fTitle,color:g,fast:$};this.$postitle?v.post_process=function(L){L.$titlebox=this.box}:(v.align=D,v.x=N===1?p:0,v.width=N===2?e:e-p,v.y=P+.05*x,v.height=.9*x),this.drawText(v)}break}case At:{const g=o.fX1?Math.round(o.fX1*e):0,D=o.fX2?Math.round(o.fX2*e):e,b=o.fY1?Math.round((1-o.fY1)*t):Math.round(P+x*.5),N=o.fY2?Math.round((1-o.fY2)*t):Math.round(P+x*.5),v=this.createAttLine(o);f.append("svg:path").attr("d",`M${g},${b}L${D},${N}`).call(v.func);break}case Lt:{const g=o.fX1?Math.round(o.fX1*e):0,D=o.fX2?Math.round(o.fX2*e):e,b=o.fY1?Math.round((1-o.fY1)*t):Math.round(P),N=o.fY2?Math.round((1-o.fY2)*t):Math.round(P+x),v=this.createAttFill(o);f.append("svg:path").attr("d",`M${g},${b}H${D}V${N}H${g}Z`).call(v.func);break}}}return w>m&&d.push(this.finishTextDrawing(f,w>m+1)),this.isTitle()&&this.getG().style("display",w?null:"none"),Promise.all(d).then(()=>this)}).then(()=>{if(!s)return;const z=Math.round(e*.5),o=Math.round(a*.04),P=f.append("svg:g");return tt(P,Math.round(e*.25),Math.round(-a*.02)),this.drawBorder(P,z,o),P.append("svg:path").attr("d",`M0,0h${z}v${o}h${-z}z`).call(this.fillatt.func).call(this.lineatt.func),this.startTextDrawingAsync(this.textatt.font,.9*o,P).then(()=>this.drawText({align:22,x:0,y:0,width:z,height:o,text:r.fLabel,color:this.textatt.color,draw_g:P})).then(()=>d.push(this.finishTextDrawing(P)))}).then(()=>this)}format(e,t){t||(t="stat");const i=this.getObject();switch(t){case"stat":t=i.fStatFormat||u.fStatFormat;break;case"fit":t=i.fFitFormat||u.fFitFormat;break;case"entries":if(Math.abs(e)<1e9&&Math.round(e)===e)return e.toFixed(0);t="14.7g";break}return pt(e,t||"6.4g")}drawLegend(e,t){const i=this.getObject(),f=i.fPrimitives.arr.length,r=Math.max(1,i.fNColumns);let n=Math.round(f/r),l=!1,h=!1;n*r<f&&n++;const a=g=>!g.fObject&&!g.fOption&&(!g.fLabel||!g.fLabel.trim());for(let g=0;g<f;++g){const D=i.fPrimitives.arr[g];a(D)?r===1&&n--:D.fLabel&&(l=!0,(D.fTextFont&&D.fTextFont!==i.fTextFont||D.fTextSize&&D.fTextSize!==i.fTextSize)&&(h=!0))}n<1&&(n=1);const s=Math.round(.03*e/r),d=Math.round(.03*t),p=(t-2*d)/(n+(n-1)*i.fEntrySeparation),x=p*i.fEntrySeparation;let c=s,S=(e-2*s-(r-1)*c)/r;i.fColumnSeparation&&(S=(e-2*s)/(r+(r-1)*i.fColumnSeparation),c=S*i.fColumnSeparation);const $=new Array(r+1).fill(s),w=S*i.fMargin;if(r>1){const g=new Array(r).fill(1),D=e-2*s-(r-1)*c-r*w;for(let N=0;N<f;++N){const v=i.fPrimitives.arr[N];if(a(v))continue;const L=N%r;g[L]=Math.max(g[L],v.fLabel.length)}let b=0;for(let N=0;N<r;++N)b+=g[N];for(let N=0;N<r-1;++N)$[N+1]=$[N]+w+g[N]/b*D+c}$[r]=e-s;let m=p,T=0,Y=!1;this.createAttText({attr:i,can_rotate:!1});const O=this.getPadPainter(),z=this.textatt.getSize(O);z&&z<m&&(m=T=z);const o=[];return(l&&!h?this.startTextDrawingAsync(this.textatt.font,m,void 0,T):Promise.resolve()).then(()=>{for(let g=0,D=-1;g<f;++g){const b=i.fPrimitives.arr[g];if(a(b))continue;r===1?++D:D=g;const N=b.fOption.toLowerCase(),v=D%r,L=(D-v)/r,M=Math.round($[v]),C=Math.round(d+L*(p+x)),y=Math.round(M+w),F=Math.round(M+(w-s)/2),I=Math.round(C+p*.1),G=Math.round(p*.8),H=Math.round(C+p*.5),k=b.fObject,zt=N.indexOf("f")!==-1,lt=N.indexOf("l")!==-1,ot=N.indexOf("e")!==-1,gt=N.indexOf("p")!==-1;let mt=b,Ct=b,ht=b,A=null,st=!1;if(kt(k)&&("fLineColor"in k&&(ht=k),"fFillColor"in k&&(mt=k),"fMarkerColor"in k&&(Ct=k),A=O.findPainterFor(k)),zt){const R=A?.fillatt?.used?A.fillatt:this.createAttFill(mt);let X;!lt&&!ot&&!gt&&(X=A?.lineatt?.used?A.lineatt:this.createAttLine(ht),X.empty()&&(X=null)),(!R.empty()||X)&&(st=!0,this.appendPath(`M${M},${I}v${G}h${y-s-M}v${-G}z`).call(R.func).call(X?X.func:()=>{}))}if(lt||ot){const R=A?.lineatt?.used?A.lineatt:this.createAttLine(ht);if(!R.empty()&&(st=!0,lt&&this.appendPath(`M${M},${H}h${y-s-M}`).call(R.func),ot)){let X=0,_=p*.05;Z(A?.getHisto)&&A.options?.ErrorKind===1?X=1:Z(A?.getGraph)&&k?.fLineWidth!==void 0&&k?.fMarkerSize!==void 0&&(X=A.options?.Ends??1,_=k.fLineWidth+u.fEndErrorSize,X>1&&(_=Math.max(_,k.fMarkerSize*8*.66)));const St=X===3?.2:0,K=Math.round(C+p*St),J=Math.round(C+p*(1-St)),B=Math.round(_*.66);_=Math.round(_);let Q=`M${F},${K}V${J}`;switch(X){case 1:Q+=`M${F-_},${K}h${2*_}M${F-_},${J}h${2*_}`;break;case 2:Q+=`M${F-_},${K+B}v${-B}h${2*_}v${B}M${F-_},${J-B}v${B}h${2*_}v${-B}`;break;case 3:Q+=`M${F-_},${K}h${2*_}l${-_},${-B}zM${F-_},${J}h${2*_}l${-_},${B}z`;break;case 4:Q+=`M${F-_},${K+B}l${_},${-B}l${_},${B}M${F-_},${J-B}l${_},${B}l${_},${-B}`;break}this.appendPath(Q).call(R.func).style("fill",X>1?"none":null)}}if(gt){const R=A?.markeratt?.used?A.markeratt:this.createAttMarker(Ct);R.empty()||(st=!0,this.appendPath(R.create(F,H)).call(R.func))}!st&&A?.lineatt&&!A.lineatt.empty()&&this.appendPath(`M${M},${I}v${G}h${y-s-M}v${-G}z`).style("fill","none").call(A.lineatt.func);let dt=y;if(E(N)&&N.toLowerCase()!=="h"?Y=!0:Y||(dt=M),b.fLabel){const R=this.createAttText({attr:b,std:!1,attr_alt:i}),X={draw_g:this.getG(),align:R.align,x:dt,width:Math.round($[v+1]-dt),y:C,height:Math.round(p),scale:h&&!b.fTextSize||!i.fTextSize,text:b.fLabel,color:R.color};h?(X.draw_g=this.getG().append("svg:g"),o.push(this.startTextDrawingAsync(R.font,R.getSize(O),X.draw_g,T).then(()=>this.drawText(X)).then(()=>this.finishTextDrawing(X.draw_g)))):this.drawText(X)}}return l&&!h&&o.push(this.finishTextDrawing()),Promise.all(o)})}isPaletteVertical(){return this.#e}drawPaletteAxis(e,t,i){const f=this.getObject(),r=f.fAxis,n=this.getG(),l=E(i)&&i.indexOf("can_move")>=0,h=E(i)&&i.indexOf("postpone")>=0,a=E(i)&&i.indexOf("cjust")>=0,s=E(i)&&i.indexOf("bring_stats_front")>=0,d=this.getPadPainter(),p=d.getPadWidth(),x=d.getPadHeight(),c=d.getRootPad(!0),S=f.$main_painter||this.getMainPainter(),$=this.getFramePainter(),w=S.getContour(!1),m=w?.getLevels(),T=Z(S.getDimension)&&S.getDimension()===3,Y=Z(S.getZaxis),O=c?.fLogv??(T?!1:c?.fLogz),z=S.getHistPalette(),o=Y?S.getZaxis():S.getObject()?.fZaxis,P=c?.fTickz?.35:.7;let g=0,D=100,b,N,v,L=0;if(this.#e=f.fX2NDC-f.fX1NDC<f.fY2NDC-f.fY1NDC,r.fTickSize=.03,typeof o?.fLabelOffset<"u"&&!T&&(r.fBits=o.fBits&~Nt.kTickMinus&~Nt.kTickPlus,r.fTitle=o.fTitle,r.fTickSize=o.fTickLength,r.fTitleSize=o.fTitleSize,r.fTitleOffset=o.fTitleOffset,r.fTextColor=o.fTitleColor,r.fTextFont=o.fTitleFont,r.fLineColor=o.fAxisColor,r.fLabelSize=o.fLabelSize,r.fLabelColor=o.fLabelColor,r.fLabelFont=o.fLabelFont,r.fLabelOffset=o.fLabelOffset,this.z_handle.setHistPainter(S,Y?"hist#z":"z"),this.z_handle.source_axis=o),w&&$&&!T?$.zmin!==void 0&&$.zmax!==void 0&&$.zmin!==$.zmax?(b=$.zmin,N=$.zmax,g=$.zoom_zmin,D=$.zoom_zmax,g===D&&(g=b,D=N)):(g=m.at(0),D=m.at(-1)):S.gmaxbin!==void 0&&S.gminbin!==void 0?(g=S.gminbin,D=S.gmaxbin):S.hmin!==void 0&&S.hmax!==void 0&&(g=S.hmin,D=S.hmax),n.selectAll("rect").style("fill","white"),(b===void 0||N===void 0||b===N)&&(b=g,N=D),this.#e?(this.#t=f.fX2NDC<.5,r.fChopt="S+"+(this.#t?"R":"L"),this.z_handle.configureAxis("zaxis",b,N,g,D,!0,[0,t],{log:O,fixed_ticks:a?m:null,maxTickSize:Math.round(e*P),swap_side:this.#t,minposbin:S.gminposbin}),v=this.#t?null:`translate(${e})`,c?.fTickz&&(L=this.#t?e:-e)):(this.#t=f.fY1NDC>.5,r.fChopt="S+",this.z_handle.configureAxis("zaxis",b,N,g,D,!1,[0,e],{log:O,fixed_ticks:a?m:null,maxTickSize:Math.round(t*P),swap_side:this.#t,minposbin:S.gminposbin}),v=this.#t?null:`translate(0,${t})`,c?.fTickz&&(L=this.#t?t:-t)),!w||!z||h)this.appendPath(`M0,0H${e}V${t}H0Z`).style("fill","white");else for(let M=0;M<m.length-1;++M){let C=Math.round(this.z_handle.gr(m[M])),y=Math.round(this.z_handle.gr(m[M+1])),F=.5,I;if(this.#e){if(y>=t||C<0)continue;C+=1,C>t?(C>y+1&&(F=.5*(t-y)/(C-y-1)),C=t,y<0&&(y=0)):y<0&&(C>1&&(F=1-.5*C/(C-y-1)),y=0),I=`M0,${y}H${e}V${C}H0Z`}else{if(C>=e||y<0)continue;y+=1,y>e?(y>C+1&&(F=1-.5*(e-C)/(y-C-1)),y=e,C<0&&(C=0)):C<0&&(y>1&&(F=.5*(y-1)/(y-C-1)),C=0),I=`M${C},0V${t}H${y}V0Z`}const G=m[M]*F+m[M+1]*(1-F),H=w.getPaletteColor(z,G);if(!H)continue;const k=this.appendPath(I).style("fill",H).property("fill0",H).property("fill1",Rt(H).darker(.5).formatRgb());this.isBatchMode()||(this.isTooltipAllowed()&&k.on("mouseover",function(){q(this).transition().duration(100).style("fill",q(this).property("fill1"))}).on("mouseout",function(){q(this).transition().duration(100).style("fill",q(this).property("fill0"))}).append("svg:title").text(this.z_handle.axisAsText(m[M])+" - "+this.z_handle.axisAsText(m[M+1])),U.Zooming&&k.on("dblclick",()=>this.getFramePainter().unzoomSingle("z")))}return s&&this.getPadPainter()?.findPainterFor(null,"",it)?.bringToFront(),this.z_handle.drawAxis(n,e,t,v,L).then(()=>{let M;if(l)if(U.ApproxTextSize||Bt()){M={x:this.#i,y:this.#a,width:e,height:t};const C=this.z_handle.labelsFont?.size||14;if(this.#e){const y=(this.z_handle._maxlbllen||3)*.6*C;M.width+=y,this.#t&&(M.x-=y)}else M.height+=C,this.#t&&(M.y-=C)}else"getBoundingClientRect"in n.node()&&(M=n.node().getBoundingClientRect());if(!M)return this;if(this.#e){const C=this.#i+parseInt(M.width)-Math.round(.995*p)+3;C>0&&(this.#i-=C,tt(n,this.#i,this.#a),f.fX1NDC-=C/p,f.fX2NDC-=C/p)}else{const C=Math.round((1.05-u.fTitleY)*x)-M.y;C>0&&(this.#a+=C,tt(n,this.#i,this.#a),f.fY1NDC-=C/x,f.fY2NDC-=C/x)}return this})}interactivePaletteAxis(e,t){let i=!1,f=0,r=0,n=null;const l=s=>{if(!i)return;s.preventDefault();const d=xt(s,this.getG().node());this.#e?(r=Math.min(Math.max(d[1],0),t),n.attr("y",Math.min(f,r)).attr("height",Math.abs(r-f))):(r=Math.min(Math.max(d[0],0),e),n.attr("x",Math.min(f,r)).attr("width",Math.abs(r-f)))},h=s=>{if(!i)return;s.preventDefault(),q(window).on("mousemove.colzoomRect",null).on("mouseup.colzoomRect",null),n.remove(),n=null,i=!1;const d=this.z_handle.revertPoint(f),p=this.z_handle.revertPoint(r);this.getFramePainter().zoomSingle("z",Math.min(d,p),Math.max(d,p),!0)},a=s=>{if(i)return;i=!0,s.preventDefault(),s.stopPropagation();const d=xt(s,this.getG().node());n=this.getG().append("svg:rect").attr("id","colzoomRect").call(Zt,!0),this.#e?(f=r=d[1],n.attr("x","0").attr("width",e).attr("y",f).attr("height",1)):(f=r=d[0],n.attr("x",f).attr("width",1).attr("y",0).attr("height",t)),q(window).on("mousemove.colzoomRect",l).on("mouseup.colzoomRect",h,!0)};U.Zooming&&this.getG().selectAll(".axis_zoom").on("mousedown",a).on("dblclick",()=>this.getFramePainter().zoomSingle("z",0,0,!0)),U.ZoomWheel&&this.getG().on("wheel",s=>{const d=xt(s,this.getG().node()),p=this.#e?1-d[1]/t:d[0]/e,x=this.z_handle.analyzeWheelEvent(s,p);x?.changed&&this.getFramePainter().zoomSingle("z",x.min,x.max,!0)})}fillContextMenuItems(e){const t=this.getObject(),i=this.isStats()?"SetOption":"SetDrawOption";e.sub("Shadow"),e.addSizeMenu("size",0,12,1,t.fBorderSize,a=>{t.fBorderSize=a,this.interactiveRedraw(!0,`exec:SetBorderSize(${a})`)}),e.addColorMenu("color",t.fShadowColor,a=>{t.fShadowColor=a,this.interactiveRedraw(!0,Ht(a,"SetShadowColor"))});const f=["nb","tr","tl","br","bl"];let r="",n=this.getPaveDrawOption(),l=n;f.forEach(a=>{const s=l.indexOf(a);s>=0&&!r&&(r=a,l=l.slice(0,s)+l.slice(s+a.length))}),e.addSelectMenu("positon",f,r||"nb",a=>{a+=l,this.setPaveDrawOption(a),this.interactiveRedraw(!0,`exec:${i}("${a}")`)},"Direction of pave shadow or nb - off"),e.endsub(),e.sub("Corner");const h=n.toLowerCase().indexOf("arc");if(e.addchk(h>=0,"arc",a=>{a?n+=" arc":n=n.slice(0,h)+n.slice(h+3),this.setPaveDrawOption(n),this.interactiveRedraw(!0,`exec:${i}("${n}")`)},"Usage of ARC draw option"),e.addSizeMenu("radius",0,.2,.02,t.fCornerRadius,a=>{t.fCornerRadius=a,this.interactiveRedraw(!0,`exec:SetCornerRadius(${a})`)},"Corner radius when ARC is enabled"),e.endsub(),(this.isStats()||this.isPaveText()||this.isPavesText())&&(e.add("Label",()=>e.input("Enter new label",t.fLabel).then(a=>{t.fLabel=a,this.interactiveRedraw("pad",`exec:SetLabel("${a}")`)})),e.addSizeMenu("Margin",0,.2,.02,t.fMargin,a=>{t.fMargin=a,this.interactiveRedraw(!0,`exec:SetMargin(${a})`)})),this.isStats()){e.add("Default position",()=>{t.fX2NDC=u.fStatX,t.fX1NDC=t.fX2NDC-u.fStatW,t.fY2NDC=u.fStatY,t.fY1NDC=t.fY2NDC-u.fStatH,t.fInit=1,this.interactiveRedraw(!0,"pave_moved")}),e.add("Save to gStyle",()=>{u.fStatX=t.fX2NDC,u.fStatW=t.fX2NDC-t.fX1NDC,u.fStatY=t.fY2NDC,u.fStatH=t.fY2NDC-t.fY1NDC,this.fillatt?.saveToStyle("fStatColor","fStatStyle"),u.fStatTextColor=t.fTextColor,u.fStatFontSize=t.fTextSize,u.fStatFont=t.fTextFont,u.fFitFormat=t.fFitFormat,u.fStatFormat=t.fStatFormat,u.fOptStat=t.fOptStat,u.fOptFit=t.fOptFit},"Store stats attributes to gStyle"),e.separator(),e.add("SetStatFormat",()=>{e.input("Enter StatFormat",t.fStatFormat).then(s=>{s&&(t.fStatFormat=s,this.interactiveRedraw(!0,`exec:SetStatFormat("${s}")`))})}),e.add("SetFitFormat",()=>{e.input("Enter FitFormat",t.fFitFormat).then(s=>{s&&(t.fFitFormat=s,this.interactiveRedraw(!0,`exec:SetFitFormat("${s}")`))})}),e.sub("SetOptStat",()=>{e.input("Enter OptStat",t.fOptStat,"int").then(s=>{t.fOptStat=s,this.interactiveRedraw(!0,`exec:SetOptStat(${s})`)})});const a=(s,d)=>{let p=s<10?t.fOptStat:t.fOptFit;p=parseInt(parseInt(p)/parseInt(Math.pow(10,s%10)))%10,e.addchk(p,d,p*100+s,x=>{const c=parseInt(x/100);let S=x%100<10?t.fOptStat:t.fOptFit;S-=(c>0?c:-1)*parseInt(Math.pow(10,x%10)),x%100<10?(t.fOptStat=S,this.interactiveRedraw(!0,`exec:SetOptStat(${S})`)):(t.fOptFit=S,this.interactiveRedraw(!0,`exec:SetOptFit(${S})`))})};a(0,"Histogram name"),a(1,"Entries"),a(2,"Mean"),a(3,"Std Dev"),a(4,"Underflow"),a(5,"Overflow"),a(6,"Integral"),a(7,"Skewness"),a(8,"Kurtosis"),e.endsub(),e.sub("SetOptFit",()=>{e.input("Enter OptStat",t.fOptFit,"int").then(s=>{t.fOptFit=s,this.interactiveRedraw(!0,`exec:SetOptFit(${s})`)})}),a(10,"Fit parameters"),a(11,"Par errors"),a(12,"Chi square / NDF"),a(13,"Probability"),e.endsub(),e.separator()}else this.isPaveText()||this.isPavesText()?(this.isPavesText()&&e.addSizeMenu("Paves",1,10,1,t.fNpaves,a=>{t.fNpaves=a,this.interactiveRedraw(!0,`exec:SetNpaves(${a})`)}),this.isTitle()&&(e.add("Default position",()=>{t.fX1NDC=u.fTitleW>0?u.fTitleX-u.fTitleW/2:u.fPadLeftMargin,t.fY1NDC=u.fTitleY-Math.min(u.fTitleFontSize*1.1,.06),t.fX2NDC=u.fTitleW>0?u.fTitleX+u.fTitleW/2:1-u.fPadRightMargin,t.fY2NDC=u.fTitleY,t.fInit=1,this.interactiveRedraw(!0,"pave_moved")}),e.add("Save to gStyle",()=>{u.fTitleX=(t.fX2NDC+t.fX1NDC)/2,u.fTitleY=t.fY2NDC,this.fillatt?.saveToStyle("fTitleColor","fTitleStyle"),u.fTitleTextColor=t.fTextColor,u.fTitleFontSize=t.fTextSize,u.fTitleFont=t.fTextFont},"Store title position and graphical attributes to gStyle"))):t._typename===V&&(e.sub("Legend"),e.add("Autoplace",()=>{this.autoPlaceLegend(t,this.getPadPainter()?.getRootPad(!0),!0).then(a=>{a&&this.interactiveRedraw(!0,"pave_moved")})}),e.addSizeMenu("Entry separation",0,1,.1,t.fEntrySeparation,a=>{t.fEntrySeparation=a,this.interactiveRedraw(!0,`exec:SetEntrySeparation(${a})`)},"Vertical entries separation, meaningful values between 0 and 1"),e.addSizeMenu("Columns separation",0,1,.1,t.fColumnSeparation,a=>{t.fColumnSeparation=a,this.interactiveRedraw(!0,`exec:SetColumnSeparation(${a})`)},"Horizontal columns separation, meaningful values between 0 and 1"),e.addSizeMenu("Num columns",1,7,1,t.fNColumns,a=>{t.fNColumns=a,this.interactiveRedraw(!0,`exec:SetNColumns(${a})`)},"Number of columns in the legend"),e.endsub())}paveContextMenu(e){if(this.z_handle){const t=this.getFramePainter();Z(t?.showContextMenu)&&t.showContextMenu("pal",e)}else Et(e,this)}isStats(){return this.matchObjectType(it)}isPaveText(){return this.matchObjectType(et)}isPavesText(){return this.matchObjectType(rt)}isPalette(){return this.matchObjectType(W)}isTitle(){return this.isPaveText()&&this.getObject()?.fName===Tt}clearPave(){this.getObject().Clear()}addText(e){this.getObject().AddText(e)}getBestFormat(e,t){const i=e.indexOf("e"),f=e.indexOf(".");return i>=0?e.indexOf("+")<0||t>=1?`.${i-f-1}e`:".1f":f<0?".1f":`.${e.length-f-1}f`}fillFunctionStat(e,t,i=1){if(this.#n=t&&e,!this.#n)return!1;this.#r=i,this.#s=0;const f=i===1?t%10:1,r=i===1?Math.floor(t/10)%10:1,n=i===1?Math.floor(t/100)%10:1,l=i===1?Math.floor(t/1e3)%10:0;if(n&&(this.addText("#chi^{2} / ndf = "+this.format(e.fChisquare,"fit")+" / "+e.fNDF),this.#s++),l&&(this.addText("Prob = "+this.format(It(e.fChisquare,e.fNDF))),this.#s++),f)for(let h=0;h<e.GetNumPars();++h){const a=e.GetParName(h);let s=e.GetParValue(h),d=e.GetParError(h);s===void 0?(s="<not avail>",d=null):(s=this.format(Number(s),"fit"),r&&d!==void 0&&(d=pt(d,this.getBestFormat(s,d)),!Number(d)&&e.GetParError(h)&&(d=pt(e.GetParError(h),"4.2g")))),r&&d?this.addText(`${a} = ${s} #pm ${d}`):this.addText(`${a} = ${s}`),this.#s++}return!0}isDummyPos(e){return e?!e.fInit&&!e.fX1&&!e.fX2&&!e.fY1&&!e.fY2&&!e.fX1NDC&&!e.fX2NDC&&!e.fY1NDC&&!e.fY2NDC:!0}updateObject(e,t){if(!this.matchObjectType(e))return!1;const i=this.getObject(),f=t===Pt;switch(!i.$modifiedNDC&&!this.isDummyPos(e)&&(this.stored&&!e.fInit&&this.stored.fX1===e.fX1&&this.stored.fX2===e.fX2&&this.stored.fY1===e.fY1&&this.stored.fY2===e.fY2?(this.stored.fX1NDC!==e.fX1NDC&&(i.fX1NDC=e.fX1NDC),this.stored.fX2NDC!==e.fX2NDC&&(i.fX2NDC=e.fX2NDC),this.stored.fY1NDC!==e.fY1NDC&&(i.fY1NDC=e.fY1NDC),this.stored.fY2NDC!==e.fY2NDC&&(i.fY2NDC=e.fY2NDC)):(i.fInit=e.fInit,i.fX1=e.fX1,i.fX2=e.fX2,i.fY1=e.fY1,i.fY2=e.fY2,i.fX1NDC=e.fX1NDC,i.fX2NDC=e.fX2NDC,i.fY1NDC=e.fY1NDC,i.fY2NDC=e.fY2NDC),this.stored=Object.assign({},e)),i.fOption=e.fOption,i.fBorderSize=e.fBorderSize,i.fTextColor!==void 0&&e.fTextColor!==void 0&&(i.fTextAngle=e.fTextAngle,i.fTextSize=e.fTextSize,i.fTextAlign=e.fTextAlign,i.fTextColor=e.fTextColor,i.fTextFont=e.fTextFont),e._typename){case nt:case et:i.fLines=Mt(e.fLines);break;case rt:i.fLines=Mt(e.fLines),i.fNpaves=e.fNpaves;break;case ut:case ct:i.fLabel=e.fLabel;break;case it:i.fOptStat=e.fOptStat,i.fOptFit=e.fOptFit;break;case V:{const r=i.fPrimitives;if(i.fPrimitives=e.fPrimitives,i.fNColumns=e.fNColumns,this.AutoPlace=f,r?.arr?.length&&r?.arr?.length===i.fPrimitives?.arr?.length)for(let n=0;n<r.arr.length;++n){const l=r.arr[n].fObject,h=i.fPrimitives.arr[n].fObject;l&&h&&l._typename===h._typename&&l.fName===h.fName&&(i.fPrimitives.arr[n].fObject=l)}return!0}case W:i.fBorderSize=1,i.fShadowColor=0;break;default:return!1}return this.storeDrawOpt(f?wt:t),!0}async redraw(){return this.drawPave()}cleanup(){this.z_handle?.cleanup(),delete this.z_handle;const e=this.getObject();e&&delete e.$main_painter,super.cleanup()}setTitlePosition(e,t,i){const f=u.fTitleX,r=u.fTitleY,n=u.fTitleAlign%10,l=(u.fTitleAlign-n)/10;let h=u.fTitleW,a=u.fTitleH,s=!1;return a<=0&&(i?a=1.1*i/this.getPadPainter().getPadHeight():(a=.05,s=!0)),h<=0&&(t?h=Math.min(.7,.02+t/this.getPadPainter().getPadWidth()):(h=.5,s=!0)),e.fX1NDC=l<2?f:l>2?f-h:f-h/2,e.fY1NDC=n<2?r:n>2?r-a:r-a/2,e.fX2NDC=e.fX1NDC+h,e.fY2NDC=e.fY1NDC+a,e.fInit=1,s}static canDraw(e){const t=e?._typename;return t===Dt||t===ut||t===ct||t===it||t===et||t===rt||t===nt||t===V||t===W}static async draw(e,t,i){const f=i,r=i===Ut,n=i===Pt;(r||n||E(i)&&i.indexOf(";")>=0)&&(i="");const l=new bt(e,t,i);return Gt(l,!1).then(()=>{if(l.isTitle()){const h=l.getPadPainter(),a=h.findPainterFor(null,Tt,et);a&&a!==l?h.removePrimitive(a):(r||l.isDummyPos(t))&&l.setTitlePosition(t)&&(l.$postitle=!0)}else t._typename===W?(t.fBorderSize=1,t.fShadowColor=0,t.fAxis&&(t.fAxis.fChopt||(t.fAxis.fChopt="+"),t.fAxis.fNdiv||(t.fAxis.fNdiv=12),t.fAxis.fLabelOffset||(t.fAxis.fLabelOffset=.005)),l.z_handle=new Wt(l.getPadPainter(),t.fAxis,!0),l.UseContextMenu=!0):t._typename===V&&(l.AutoPlace=n);return l.NoFillStats=t.fName!=="stats",l.drawPave(f)}).then(()=>{const h=l.$postitle&&l.$titlebox;return h&&l.setTitlePosition(t,l.$titlebox.width,l.$titlebox.height),delete l.$postitle,delete l.$titlebox,h?l.drawPave(f):l})}}export{bt as TPavePainter,Ut as kPosTitle};
