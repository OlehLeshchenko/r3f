import{m as y,K as m,bp as k}from"./index-DAa9yKAB.js";import{RObjectPainter as w,ensureRCanvas as p}from"./RCanvasPainter-BGRtT7_9.js";const c={kTopLeft:1,kTopRight:2,kBottomLeft:3,kBottomRight:4};class v extends w{async drawContent(){return this}async drawPave(){const t=this.getPadPainter().getPadRect(),s=this.getFramePainter();this.onFrame=s&&this.v7EvalAttr("onFrame",!0),this.corner=this.v7EvalAttr("corner",c.kTopRight);const r=this.v7EvalAttr("visible",!0),e=this.v7EvalLength("offsetX",t.width,.02),h=this.v7EvalLength("offsetY",t.height,.02),o=this.v7EvalLength("width",t.width,.3),i=this.v7EvalLength("height",t.height,.3),n=this.createG();if(n.classed("most_upper_primitives",!0),!r)return this;this.createv7AttLine("border_"),this.createv7AttFill();const a=this.onFrame?s.getFrameRect():t;let f=0,l=0;switch(this.corner){case c.kTopLeft:f=a.x+e,l=a.y+h;break;case c.kBottomLeft:f=a.x+e,l=a.y+a.height-h-i;break;case c.kBottomRight:f=a.x+a.width-e-o,l=a.y+a.height-h-i;break;case c.kTopRight:default:f=a.x+a.width-e-o,l=a.y+h}return y(n,f,l),n.append("svg:rect").attr("x",0).attr("width",o).attr("y",0).attr("height",i).call(this.lineatt.func).call(this.fillatt.func),this.pave_width=o,this.pave_height=i,this.drawContent().then(()=>(this.isBatchMode()||(m.ContextMenu&&this.paveContextMenu&&n.on("contextmenu",g=>this.paveContextMenu(g)),k(this,{x:f,y:l,width:o,height:i,minwidth:20,minheight:20,redraw:g=>this.sizeChanged(g)})),this))}sizeChanged(t){this.pave_width=t.width,this.pave_height=t.height;const s=t.x,r=t.y,e=this.getPadPainter().getPadRect(),h=this.onFrame?this.getFramePainter().getFrameRect():e,o={};let i,n;switch(this.corner){case c.kTopLeft:i=s-h.x,n=r-h.y;break;case c.kBottomLeft:i=s-h.x,n=h.y+h.height-r-this.pave_height;break;case c.kBottomRight:i=h.x+h.width-s-this.pave_width,n=h.y+h.height-r-this.pave_height;break;case c.kTopRight:default:i=h.x+h.width-s-this.pave_width,n=r-h.y}this.v7AttrChange(o,"offsetX",i/e.width),this.v7AttrChange(o,"offsetY",n/e.height),this.v7AttrChange(o,"width",this.pave_width/e.width),this.v7AttrChange(o,"height",this.pave_height/e.height),this.v7SendAttrChanges(o,!1),this.getG().selectChild("rect").attr("width",this.pave_width).attr("height",this.pave_height),this.drawContent()}async redraw(){return this.drawPave()}static async draw(t,s,r){const e=new v(t,s,r,"pave");return p(e).then(()=>e.drawPave())}}class x extends v{async drawContent(){const t=this.getObject(),s=this.v7EvalFont("text",{size:12,color:"black",align:22}),r=this.pave_width,e=this.pave_height,h=this.getPadPainter();let o=t.fEntries.length;if(t.fTitle&&o++,!o||!h)return this;const i=e/o,n=.02*r;return s.setSize(e/(o*1.2)),this.startTextDrawingAsync(s,"font").then(()=>{let a=0;t.fTitle&&(this.drawText({latex:1,width:r-2*n,height:i,x:n,y:a,text:t.fTitle}),a+=i);for(let f=0;f<t.fEntries.length;++f){const l=t.fEntries[f],g=Math.round(r/4);let d=null;this.drawText({latex:1,width:.75*r-3*n,height:i,x:2*n+g,y:a,text:l.fLabel}),l.fDrawableId!=="custom"?d=h.findSnap(l.fDrawableId,!0):l.fDrawable.fIO&&(d=new w(this.getPadPainter(),l.fDrawable.fIO),l.fLine&&d.createv7AttLine(),l.fFill&&d.createv7AttFill(),l.fMarker&&d.createv7AttMarker()),l.fFill&&d?.fillatt&&this.appendPath(`M${Math.round(n)},${Math.round(a+i*.1)}h${g}v${Math.round(i*.8)}h${-g}z`).call(d.fillatt.func),l.fLine&&d?.lineatt&&this.appendPath(`M${Math.round(n)},${Math.round(a+i/2)}h${g}`).call(d.lineatt.func),l.fError&&d?.lineatt&&this.appendPath(`M${Math.round(n+r/8)},${Math.round(a+i*.2)}v${Math.round(i*.6)}`).call(d.lineatt.func),l.fMarker&&d?.markeratt&&this.appendPath(d.markeratt.create(n+r/8,a+i/2)).call(d.markeratt.func),a+=i}return this.finishTextDrawing()})}static async draw(t,s,r){const e=new x(t,s,r,"legend");return p(e).then(()=>e.drawPave())}}class u extends v{async drawContent(){const t=this.getObject(),s=t?.fText.length;if(!s)return;const r=this.v7EvalFont("text",{size:12,color:"black",align:22}),e=this.pave_width,h=this.pave_height,o=h/s,i=.02*e;return r.setSize(h/(s*1.2)),this.startTextDrawingAsync(r,"font").then(()=>{for(let n=0,a=0;n<t.fText.length;++n,a+=o)this.drawText({latex:1,width:e-2*i,height:o,x:i,y:a,text:t.fText[n]});return this.finishTextDrawing(void 0,!0)})}static async draw(t,s,r){const e=new u(t,s,r,"pavetext");return p(e).then(()=>e.drawPave())}}export{x as RLegendPainter,v as RPavePainter,u as RPaveTextPainter};
