import{O as ot,D as Nt,C as ct,F as V,l as rt,p as ut,G as dt,s as Xt,q as Yt,T as H,H as mt,v as tt,I as xt,J as pt,K as gt,P as Mt,L as yt}from"./index-DAa9yKAB.js";import{TH2Painter as nt}from"./TH2Painter-yQJYXbd3.js";import{a as wt}from"./TH2Painter-Ba0oelVz.js";import{c as Tt,a as Ct}from"./hist3d-BC5Tno_J.js";import"./THistPainter-DJAmNO-k.js";import"./TPavePainter-DMWA3hUD.js";import"./latex3d-BISPawP1.js";function at(E){let t=E[0];for(let f=1;f<E.length;++f)t=Math.max(t,E[f]);return t}function lt(E){let t=E[0];for(let f=1;f<E.length;++f)t=Math.min(t,E[f]);return t}function _t(E,t,f){const i=new Array(E);for(let s=0;s<E;++s)i[s]={v:t[s],i:s};i.sort((s,N)=>s.v<N.v?-1:s.v>N.v?1:0);for(let s=0;s<E;++s)f[s]=i[s].i}class zt{constructor(t){this.fGraph2D=t,this.fX=t.fX,this.fY=t.fY,this.fZ=t.fZ,this.fNpoints=t.fNpoints,this.fZout=0,this.fNdt=0,this.fNhull=0,this.fHullPoints=null,this.fXN=null,this.fYN=null,this.fOrder=null,this.fDist=null,this.fPTried=null,this.fNTried=null,this.fMTried=null,this.fInit=!1,this.fXNmin=0,this.fXNmax=0,this.fYNmin=0,this.fYNmax=0,this.fXoffset=0,this.fYoffset=0,this.fXScaleFactor=0,this.fYScaleFactor=0,this.SetMaxIter()}Initialize(){this.fInit||(this.CreateTrianglesDataStructure(),this.FindHull(),this.fInit=!0)}ComputeZ(t,f){this.Initialize();const i=(t+this.fXoffset)*this.fXScaleFactor,s=(f+this.fYoffset)*this.fYScaleFactor;let N=this.Interpolate(i,s);return N===0&&(N=this.Interpolate(i+1e-4,s)),N}CreateTrianglesDataStructure(){const t=at(this.fGraph2D.fX),f=at(this.fGraph2D.fY),i=lt(this.fGraph2D.fX),s=lt(this.fGraph2D.fY);this.fXoffset=-(t+i)/2,this.fYoffset=-(f+s)/2,this.fXScaleFactor=1/(t-i),this.fYScaleFactor=1/(f-s),this.fXNmax=(t+this.fXoffset)*this.fXScaleFactor,this.fXNmin=(i+this.fXoffset)*this.fXScaleFactor,this.fYNmax=(f+this.fYoffset)*this.fYScaleFactor,this.fYNmin=(s+this.fYoffset)*this.fYScaleFactor,this.fXN=new Array(this.fNpoints+1),this.fYN=new Array(this.fNpoints+1);for(let N=0;N<this.fNpoints;N++)this.fXN[N+1]=(this.fX[N]+this.fXoffset)*this.fXScaleFactor,this.fYN[N+1]=(this.fY[N]+this.fYoffset)*this.fYScaleFactor;this.fPTried=[],this.fNTried=[],this.fMTried=[]}Enclose(t,f,i,s){const N=[this.fXN[t],this.fXN[f],this.fXN[i],this.fXN[t]],e=[this.fYN[t],this.fYN[f],this.fYN[i],this.fYN[t]],o=this.fXN[s],l=this.fYN[s];let m=0,x=N.length-1,u=!1;for(;m<N.length;++m)(e[m]<l&&e[x]>=l||e[x]<l&&e[m]>=l)&&N[m]+(l-e[m])/(e[x]-e[m])*(N[x]-N[m])<o&&(u=!u),x=m;return u}FileIt(t,f,i){let s,N=t,e=f,o=i;do s=!1,e>N&&([e,N]=[N,e],s=!0),o>e&&([o,e]=[e,o],s=!0);while(s);this.fNdt++,this.fPTried.push(N),this.fNTried.push(e),this.fMTried.push(o)}FindAllTriangles(){if(this.fAllTri)return;this.fAllTri=!0;let t,f,i,s,N,e,o,l,m,x,u,X,a,h,p,r,n,w,C,Y,y,c,_,k=0,M=0,P,g,Z=0;const d=[!1,!1,!1],F=1e-4;for(this.Initialize(),t=0,f=0,g=1;g<=this.fNhull;g++)t+=this.fXN[this.fHullPoints[g-1]],f+=this.fYN[this.fHullPoints[g-1]];for(t=t/this.fNhull+F,f=f/this.fNhull+F,this.Interpolate(t,f),r=1;r<=this.fNdt;){for(w=this.fPTried[r-1],C=this.fNTried[r-1],Y=this.fMTried[r-1],d[0]=!1,d[1]=!1,d[2]=!1,n=1;n<=this.fNdt;n++)n!==r&&(y=this.fPTried[n-1],c=this.fNTried[n-1],_=this.fMTried[n-1],w===y&&C===c||w===y&&C===_||w===c&&C===_?d[0]=!0:w===y&&Y===c||w===y&&Y===_||w===c&&Y===_?d[1]=!0:(C===y&&Y===c||C===y&&Y===_||C===c&&Y===_)&&(d[2]=!0)),d[0]&&d[1]&&d[2];for(P=1;P<=3;P++)d[P-1]||(P===1?(k=w,M=C,Z=Y):P===2?(k=w,M=Y,Z=C):P===3&&(k=C,M=Y,Z=w),i=(this.fXN[k]+this.fXN[M])/2,s=(this.fYN[k]+this.fYN[M])/2,o=this.fXN[k]-this.fXN[M],l=this.fYN[k]-this.fYN[M],m=l,x=-o,h=Math.sqrt(m*m+x*x),m/=h,x/=h,u=this.fXN[Z]-i,X=this.fYN[Z]-s,a=u*m+X*x,a>0&&(m=-m,x=-x),p=Math.abs(Math.max(F*i,F*s)),N=i+m*p,e=s+x*p,this.Interpolate(N,e));r++}}FindHull(){this.fHullPoints||(this.fHullPoints=new Array(this.fNpoints));let t=0;for(let f=1;f<=this.fNpoints;f++)this.InHull(f,f)||(t++,this.fHullPoints[t-1]=f);this.fNhull=t}InHull(t,f){let i,s,N,e,o,l,m,x,u,X,a,h,p,r,n,w,C,Y,y,c,_,k=!1;const M=this.fXN[t],P=this.fYN[t];for(this.fNhull>0?o=this.fNhull:o=this.fNpoints,i=1,s=2,i===f?(i=s,s++):s===f&&s++,u=M-this.fXN[i],h=P-this.fYN[i],X=M-this.fXN[s],p=P-this.fYN[s],y=Math.atan2(h,u),c=Math.atan2(p,X),_=y-c-Math.floor((y-c)/(Math.PI*2))*Math.PI*2,_<0&&(_+=Math.PI*2),l=_,N=1;N<=o;N++)if(this.fNhull>0?e=this.fHullPoints[N-1]:e=N,e!==i&&e!==s&&e!==f&&(u=M-this.fXN[i],h=P-this.fYN[i],X=M-this.fXN[s],p=P-this.fYN[s],a=M-this.fXN[e],r=P-this.fYN[e],m=X*h-u*p,x=u*p-X*h,m*x&&(n=(X*r-a*p)/m,w=(u*r-a*h)/x,n<0||w<0))){if(C=(u*a+h*r)/Math.sqrt(u*u+h*h),Y=(X*a+p*r)/Math.sqrt(X*X+p*p),C>Y?(i=e,y=Math.atan2(r,a),c=Math.atan2(p,X)):(s=e,y=Math.atan2(h,u),c=Math.atan2(r,a)),_=y-c-Math.floor((y-c)/(Math.PI*2))*Math.PI*2,_<0&&(_+=Math.PI*2),(_-Math.PI)*(l-Math.PI)<0)return k=!0,k;l=_}return k}InterpolateOnPlane(t,f,i,s){let N,e=t,o=f,l=i;do N=!1,o>e&&([e,o]=[o,e],N=!0),l>o&&([o,l]=[l,o],N=!0);while(N);const m=this.fXN[e],x=this.fXN[o],u=this.fXN[l],X=this.fYN[e],a=this.fYN[o],h=this.fYN[l],p=this.fZ[e-1],r=this.fZ[o-1],n=this.fZ[l-1],w=(p*(a-h)+r*(h-X)+n*(X-a))/(m*(a-h)+x*(h-X)+u*(X-a)),C=(p*(x-u)+r*(u-m)+n*(m-x))/(X*(x-u)+a*(u-m)+h*(m-x)),Y=p-w*m-C*X;return w*this.fXN[s]+C*this.fYN[s]+Y}Interpolate(t,f){let i,s,N,e,o,l,m,x,u,X,a,h,p,r,n,w,C,Y,y,c,_=0,k=0,M=0,P=0,g=0,Z,d,F,I,S,A,b,O,G,q,v,D,L,z,T,R,W,U,J,K,Q,et,ft;const B=[0,0,0],$=[0,0,0];if(this.Initialize(),this.fOrder||(this.fOrder=new Array(this.fNpoints),this.fDist=new Array(this.fNpoints)),this.fXN[0]=t,this.fYN[0]=f,i=this.fZout,N=0,t>this.fXNmax||t<this.fXNmin||f>this.fYNmax||f<this.fYNmin)return i;for(s=1;s<=this.fNdt;s++)if(e=this.fPTried[s-1],o=this.fNTried[s-1],l=this.fMTried[s-1],this.Enclose(e,o,l,0))return i=this.InterpolateOnPlane(e,o,l,0),i;const ht=this.InHull(0,-1);if(!ht)return i;for(s=1;s<=this.fNpoints;s++)Z=this.fXN[s],d=this.fYN[s],this.fDist[s-1]=Math.sqrt((t-Z)*(t-Z)+(f-d)*(f-d));for(_t(this.fNpoints,this.fDist,this.fOrder),s=0;s<this.fNpoints;s++)this.fOrder[s]++;for(u=3;u<=this.fNpoints;u++)for(l=this.fOrder[u-1],x=2;x<=u-1;x++)for(o=this.fOrder[x-1],m=1;m<=x-1;m++){let j=!1;if(e=this.fOrder[m-1],N>this.fMaxIter)return i;if(N++,F=Math.sqrt((this.fXN[e]-this.fXN[o])**2+(this.fYN[e]-this.fYN[o])**2),I=Math.sqrt((this.fXN[e]-this.fXN[l])**2+(this.fYN[e]-this.fYN[l])**2),S=Math.sqrt((this.fXN[o]-this.fXN[l])**2+(this.fYN[o]-this.fYN[l])**2),!(F+I<=S||F+S<=I||I+S<=F)&&this.Enclose(e,o,l,0)){for(_=0,a=1;a<=this.fNpoints;a++)if(!(a===e||a===o||a===l)){for(X=1;X<=this.fNpoints;X++)if(this.fOrder[X-1]===a)if(X<m||X<x||X<u){if(this.Enclose(e,o,l,a)){j=!0;break}}else break;if(j)break;if((this.fXN[e]-this.fXN[a])*(this.fYN[e]-this.fYN[o])===(this.fYN[e]-this.fYN[a])*(this.fXN[e]-this.fXN[o])?(w=e,C=o):(this.fXN[e]-this.fXN[a])*(this.fYN[e]-this.fYN[l])===(this.fYN[e]-this.fYN[a])*(this.fXN[e]-this.fXN[l])?(w=e,C=l):(this.fXN[o]-this.fXN[a])*(this.fYN[o]-this.fYN[l])===(this.fYN[o]-this.fYN[a])*(this.fXN[o]-this.fXN[l])?(w=o,C=l):(w=0,C=0),w){if(this.fXN[w]!==this.fXN[C])if((this.fXN[a]-this.fXN[w])*(this.fXN[a]-this.fXN[C])<0){j=!0;break}else(this.fXN[a]-this.fXN[w])*(this.fXN[a]-this.fXN[C])===0&&console.warn(`Interpolate Two of these three points are coincident ${w} ${C} ${a}`);else if((this.fYN[a]-this.fYN[w])*(this.fYN[a]-this.fYN[C])<0){j=!0;break}else(this.fYN[a]-this.fYN[w])*(this.fYN[a]-this.fYN[C])===0&&console.warn(`Interpolate Two of these three points are coincident ${w} ${C} ${a}`);continue}if(j)break;for(h=l,r=e,n=o,B[0]=this.fXN[e]-this.fXN[a],$[0]=this.fYN[e]-this.fYN[a],B[1]=this.fXN[o]-this.fXN[a],$[1]=this.fYN[o]-this.fYN[a],B[2]=this.fXN[l]-this.fXN[a],$[2]=this.fYN[l]-this.fYN[a],X=1;X<=3;X++)if(R=B[X-1],W=B[X%3],U=B[(X+1)%3],J=$[X-1],K=$[X%3],Q=$[(X+1)%3],et=(Q*W-U*K)*(J*W-R*K),ft=(Q*R-U*J)*(K*R-W*J),et>=0&&ft>=0){X===1?(h=l,r=e,n=o):X===2?(h=e,r=o,n=l):(h=o,r=l,n=e);break}if(L=((this.fXN[h]-this.fXN[r])*(this.fXN[a]-this.fXN[r])+(this.fYN[h]-this.fYN[r])*(this.fYN[a]-this.fYN[r]))/Math.sqrt(((this.fXN[h]-this.fXN[r])*(this.fXN[h]-this.fXN[r])+(this.fYN[h]-this.fYN[r])*(this.fYN[h]-this.fYN[r]))*((this.fXN[a]-this.fXN[r])*(this.fXN[a]-this.fXN[r])+(this.fYN[a]-this.fYN[r])*(this.fYN[a]-this.fYN[r]))),z=((this.fXN[n]-this.fXN[r])*(this.fXN[a]-this.fXN[r])+(this.fYN[n]-this.fYN[r])*(this.fYN[a]-this.fYN[r]))/Math.sqrt(((this.fXN[n]-this.fXN[r])*(this.fXN[n]-this.fXN[r])+(this.fYN[n]-this.fYN[r])*(this.fYN[n]-this.fYN[r]))*((this.fXN[a]-this.fXN[r])*(this.fXN[a]-this.fXN[r])+(this.fYN[a]-this.fYN[r])*(this.fYN[a]-this.fYN[r]))),T=((this.fXN[n]-this.fXN[r])*(this.fXN[h]-this.fXN[r])+(this.fYN[n]-this.fYN[r])*(this.fYN[h]-this.fYN[r]))/Math.sqrt(((this.fXN[n]-this.fXN[r])*(this.fXN[n]-this.fXN[r])+(this.fYN[n]-this.fYN[r])*(this.fYN[n]-this.fYN[r]))*((this.fXN[h]-this.fXN[r])*(this.fXN[h]-this.fXN[r])+(this.fYN[h]-this.fYN[r])*(this.fYN[h]-this.fYN[r]))),!(L>z||L>T))if(O=Math.sqrt((this.fXN[a]-this.fXN[r])*(this.fXN[a]-this.fXN[r])+(this.fYN[a]-this.fYN[r])*(this.fYN[a]-this.fYN[r])),G=Math.sqrt((this.fXN[a]-this.fXN[n])*(this.fXN[a]-this.fXN[n])+(this.fYN[a]-this.fYN[n])*(this.fYN[a]-this.fYN[n])),q=Math.sqrt((this.fXN[h]-this.fXN[r])*(this.fXN[h]-this.fXN[r])+(this.fYN[h]-this.fYN[r])*(this.fYN[h]-this.fYN[r])),v=Math.sqrt((this.fXN[h]-this.fXN[n])*(this.fXN[h]-this.fXN[n])+(this.fYN[h]-this.fYN[n])*(this.fYN[h]-this.fYN[n])),A=((this.fXN[a]-this.fXN[r])*(this.fXN[a]-this.fXN[n])+(this.fYN[a]-this.fYN[r])*(this.fYN[a]-this.fYN[n]))/O/G,b=((this.fXN[h]-this.fXN[r])*(this.fXN[h]-this.fXN[n])+(this.fYN[h]-this.fYN[r])*(this.fYN[h]-this.fYN[n]))/q/v,D=A*Math.sqrt(1-b*b)+b*Math.sqrt(1-A*A),D<-1e-6){j=!0;break}else Math.abs(D)<=1e-6&&(_++,k=a,M=h,P=r,g=n)}if(!j)return _>0?(p=k,h=M,r=P,n=g,this.fZ[r-1]+this.fZ[n-1]>this.fZ[p-1]+this.fZ[h-1]?(Y=e,y=o,c=l,this.FileIt(e,o,l),this.FileIt(p,r,n)):(Y=h,y=p,this.Enclose(h,p,r,0)?c=r:c=n,this.FileIt(h,p,r),this.FileIt(h,p,n))):(this.FileIt(e,o,l),Y=e,y=o,c=l),i=this.InterpolateOnPlane(Y,y,c,0),i}}return ht&&console.error(`Interpolate Point outside hull when expected inside: this point could be dodgy ${t}  ${f} ${N}`),i}SetMaxIter(t=1e5){this.fAllTri=!1,this.fMaxIter=t}SetMarginBinsContent(t){this.fZout=t}GetContourList(t){if(!this.fNdt)return null;let f,i,s,N,e,o,l,m,x,u,X,a,h,p,r,n,w,C,Y,y,c=0,_,k,M,P;const g=[0,0,0],Z=new Array(this.fNdt).fill(0),d=new Array(this.fNdt).fill(0),F=new Array(this.fNdt).fill(0),I=new Array(this.fNdt).fill(0);for(w=0;w<this.fNdt;w++){if(g[0]=this.fPTried[w],g[1]=this.fNTried[w],g[2]=this.fMTried[w],e=g[0]-1,o=g[1]-1,l=g[2]-1,m=this.fX[e],p=this.fX[e],x=this.fY[e],r=this.fY[e],u=this.fZ[e],n=this.fZ[e],C=Y=y=0,this.fZ[o]<=u&&(u=this.fZ[o],m=this.fX[o],x=this.fY[o],C=1),this.fZ[o]>n&&(n=this.fZ[o],p=this.fX[o],r=this.fY[o],y=1),this.fZ[l]<=u&&(u=this.fZ[l],m=this.fX[l],x=this.fY[l],C=2),this.fZ[l]>n&&(n=this.fZ[l],p=this.fX[l],r=this.fY[l],y=2),C===0&&y===0)return console.error("GetContourList: wrong vertices ordering"),null;Y=3-y-C,X=this.fX[g[Y]-1],a=this.fY[g[Y]-1],h=this.fZ[g[Y]-1],t>=u&&t<=n&&(s=(t-u)/(n-u),_=s*(p-m)+m,k=s*(r-x)+x,t>=h&&t<=n?(i=(t-h)/(n-h),M=i*(p-X)+X,P=i*(r-a)+a):(N=(t-u)/(h-u),M=N*(X-m)+m,P=N*(a-x)+x),(_!==M||k!==P)&&(c++,Z[c-1]=_,d[c-1]=k,F[c-1]=M,I[c-1]=P))}const S=[],A=new Array(this.fNdt).fill(!1);let b=0,O=0,G=0,q=0,v,D,L,z,T;for(z=0;z<c;z++)if(!A[z]){for(D=L=!1,T=0;T<c;T++)z!==T&&(Z[z]===Z[T]&&d[z]===d[T]&&(D=!0),Z[z]===F[T]&&d[z]===I[T]&&(D=!0),F[z]===Z[T]&&I[z]===d[T]&&(L=!0),F[z]===F[T]&&I[z]===I[T]&&(L=!0));if(!D&&!L){f=[],f.push(Z[z],d[z]),f.push(F[z],I[z]),A[z]=!0,S.push(f);continue}if(!D||!L){for(f=[],D&&(b=Z[z],O=d[z],G=F[z],q=I[z]),L&&(b=F[z],O=I[z],G=Z[z],q=d[z]),f.push(G,q),A[z]=!0,T=0;;){for(v=!1;T<c&&A[T];)T++;if(b===Z[T]&&O===d[T]?(b=F[T],O=I[T],v=!0):b===F[T]&&O===I[T]&&(b=Z[T],O=d[T],v=!0),v)A[T]=!0,f.push(b,O),T=0;else if(++T>=c)break}S.push(f)}}for(z=0;z<c;z++)if(!A[z]){for(f=[],A[z]=!0,b=Z[z],O=d[z],T=0,f.push(b,O);;){for(;T<c&&A[T];)T++;if(v=!1,b===Z[T]&&O===d[T]?(b=F[T],O=I[T],v=!0):b===F[T]&&O===I[T]&&(b=Z[T],O=d[T],v=!0),v)A[T]=!0,f.push(b,O),T=0;else if(++T>=c)break}f.push(Z[z],d[z]),S.push(f)}return S}}function it(E){let t=Math.floor(E.index/this.nvertex);if(t<0||t>=this.index.length)return null;const f=l=>l*l;t=this.index[t];const i=this.fp,s=this.graph;let N=i.grx(s.fX[t]),e=i.gry(s.fY[t]),o=i.grz(s.fZ[t]);if(this.check_next&&t+1<s.fX.length){const l=E.point,m=i.grx(s.fX[t+1]),x=i.gry(s.fY[t+1]),u=i.grz(s.fZ[t+1]);f(l.x-m)+f(l.y-x)+f(l.z-u)<f(l.x-N)+f(l.y-e)+f(l.z-o)&&(N=m,e=x,o=u,t++)}return{x1:N-this.scale0,x2:N+this.scale0,y1:e-this.scale0,y2:e+this.scale0,z1:o-this.scale0,z2:o+this.scale0,color:this.tip_color,lines:[this.tip_name,"pnt: "+t,"x: "+i.axisAsText("x",s.fX[t]),"y: "+i.axisAsText("y",s.fY[t]),"z: "+i.axisAsText("z",s.fZ[t])]}}class st extends ot{#i;#t;decodeOptions(t){const f=new Nt(t),i=this.getObject();f.check("FILL_","color")&&i&&(i.fFillColor=f.color),f.check("LINE_","color")&&i&&(i.fLineColor=f.color),f.check("SAME");let s=0,N=0;f.check("CONT5")?N=15:f.check("TRI1")?s=11:f.check("TRI2")?s=10:f.check("TRIW")?s=1:f.check("TRI")&&(s=2);const e=this.setOptions({Triangles:s,Contour:N,Line:f.check("LINE"),Error:f.check("ERR")&&(this.matchObjectType(ct)||this.matchObjectType(V))});f.check("P0COL")?e.Color=e.Circles=e.Markers=!0:(e.Color=f.check("COL"),e.Circles=f.check("P0"),e.Markers=f.check("P")),e.Markers||(e.Color=!1),(e.Color||e.Triangles>=10||e.Contour)&&(e.Zscale=f.check("Z")),e.isAny=function(){return this.Markers||this.Error||this.Circles||this.Line||this.Triangles||e.Contour},e.Contour?e.Axis="":e.isAny()?(e.Axis="lego2",e.Zscale&&(e.Axis+="z")):e.Axis=t,this.storeDrawOpt(t)}createHistogram(){const t=this.getObject(),f=this.getOptions(),i=this.matchObjectType(V);let s=t.fX[0],N=s,e=t.fY[0],o=e,l=t.fZ[0],m=l;for(let c=0;c<t.fNpoints;++c){const _=t.fX[c],k=t.fY[c],M=t.fZ[c];f.Error?(s=Math.min(s,_-(i?t.fEXlow[c]:t.fEX[c])),N=Math.max(N,_+(i?t.fEXhigh[c]:t.fEX[c])),e=Math.min(e,k-(i?t.fEYlow[c]:t.fEY[c])),o=Math.max(o,k+(i?t.fEYhigh[c]:t.fEY[c])),l=Math.min(l,M-(i?t.fEZlow[c]:t.fEZ[c])),m=Math.max(m,M+(i?t.fEZhigh[c]:t.fEZ[c]))):(s=Math.min(s,_),N=Math.max(N,_),e=Math.min(e,k),o=Math.max(o,k),l=Math.min(l,M),m=Math.max(m,M))}function x(c,_,k){return c<_?k*(_-c):Math.abs(c)<1e5?.02:.02*Math.abs(c)}const u=x(s,N,t.fMargin),X=x(e,o,t.fMargin),a=x(l,m,0);let h=s-u,p=N+u,r=e-X,n=o+X,w=l-a,C=m+a;h<0&&s>=0&&(h=s*.98),p>0&&N<=0&&(p=0),r<0&&e>=0&&(r=e*.98),n>0&&o<=0&&(n=0),w<0&&l>=0&&(w=l*.98),C>0&&m<=0&&(C=0);const Y=this.getObject();Y.fMinimum!==rt&&(w=Y.fMinimum),Y.fMaximum!==rt&&(C=Y.fMaximum);const y=ut(dt,Y.fNpx,Y.fNpy);if(y.fName=Y.fName+"_h",Xt(y,Y.fTitle),y.fXaxis.fXmin=h,y.fXaxis.fXmax=p,y.fYaxis.fXmin=r,y.fYaxis.fXmax=n,y.fZaxis.fXmin=w,y.fZaxis.fXmax=C,y.fMinimum=w,y.fMaximum=C,y.fBits|=Yt,!f.isAny()){const c=this.buildDelaunay(Y);if(c)for(let _=0;_<Y.fNpx;++_){const k=h+(_+.5)/Y.fNpx*(p-h);for(let M=0;M<Y.fNpy;++M){const P=r+(M+.5)/Y.fNpy*(n-r),g=c.ComputeZ(k,P);y.fArray[y.getBin(_+1,M+1)]=g}}}return y}buildDelaunay(t){return this.#t||(this.#t=new zt(t),this.#t.FindAllTriangles(),this.#t.fNdt||(this.#t=void 0)),this.#t}drawTriangles(t,f,i,s){const N=this.buildDelaunay(f);if(!N)return;const e=t.logz?X=>X<t.scale_zmin?-.1:t.grz(X):t.grz,o=this.getOptions(),l=o.Triangles===2,m=o.Triangles>=10||l,x=o.Triangles%10===1||l&&f.fLineColor!==f.fFillColor,u=new wt(i,e,0,2*t.size_z3d,x);for(u.loop=0;u.loop<2;++u.loop){u.createBuffers();for(let X=0;X<N.fNdt;++X){const a=[N.fPTried[X],N.fNTried[X],N.fMTried[X]],h=[];let p=!0;for(let r=0;r<3;++r){const n=a[r]-1;h.push(t.grx(f.fX[n]),t.gry(f.fY[n]),e(f.fZ[n])),(f.fX[n]<t.scale_xmin||f.fX[n]>t.scale_xmax||f.fY[n]<t.scale_ymin||f.fY[n]>t.scale_ymax)&&(p=!1)}m&&p&&u.addMainTriangle(...h),x&&p&&(u.addLineSegment(h[0],h[1],h[2],h[3],h[4],h[5]),u.addLineSegment(h[3],h[4],h[5],h[6],h[7],h[8]),u.addLineSegment(h[6],h[7],h[8],h[0],h[1],h[2]))}}u.callFuncs((X,a)=>{const h=Tt(this.getMainPainter(),a,null,100,100),p=l?this.getColor(f.fFillColor):s.calcColor(X,i.length),r=new H.MeshBasicMaterial(mt(p,{side:H.DoubleSide,vertexColors:!1})),n=new H.Mesh(h,r);t.add3DMesh(n,this),n.painter=this},(X,a)=>{const h=this.getColor(f.fLineColor),p=new H.LineBasicMaterial({color:new H.Color(h),linewidth:f.fLineWidth}),r=tt(Ct(this.getMainPainter(),a,100,100),p);t.add3DMesh(r,this)})}updateObject(t,f){if(!this.matchObjectType(t))return!1;const i=this.getOptions();if(f&&f!==i.original&&this.decodeOptions(f,t),Object.assign(this.getObject(),t),this.#t=void 0,this.#i=void 0,this.axes_draw){const s=this.getMainPainter();s?.updateObject(this.createHistogram(),i.Axis),this.#i=s}return!0}async redraw(){const t=xt(this.#i?.redraw());return this.#i=void 0,t.then(()=>this.drawGraph2D())}async drawContour(t,f,i){const s=this.buildDelaunay(i);if(!s)return this;const N=f.getContour(),e=f.getHistPalette(),o=N.getLevels(),l=t.getGrFuncs(),m=this.createG(!0);this.createAttLine({attr:i,nocolor:!0});for(let x=0;x<o.length;++x){const u=s.GetContourList(o[x]),X=N.getPaletteColor(e,o[x]);let a="";for(let h=0;h<u.length;++h){const p=u[h],r=[];for(let n=0;n<p.length;n+=2)r.push({grx:l.grx(p[n]),gry:l.gry(p[n+1])});a+=pt(r,{cmd:"M",line:!0})}this.lineatt.color=X,m.append("svg:path").attr("d",a).style("fill","none").call(this.lineatt.func)}return this}async drawGraph2D(){const t=this.getFramePainter(),f=this.getMainPainter(),i=this.getObject(),s=this.getOptions();if(!i||!f||!t)return this;if(s.Contour)return this.drawContour(t,f,i);if(!t.mode3d)return this;if(t.remove3DMeshes(this),!s.isAny()){if(f.draw_content)return this;i.fMarkerSize===1&&i.fMarkerStyle===1?s.Circles=!0:s.Markers=!0}const N=(h,p)=>{let r=0;for(let n=0;n<i.fNpoints;++n)i.fX[n]>=t.scale_xmin&&i.fX[n]<=t.scale_xmax&&i.fY[n]>=t.scale_ymin&&i.fY[n]<=t.scale_ymax&&i.fZ[n]>=h&&i.fZ[n]<p&&++r;return r};let e=1;if(gt.OptimizeDraw>0&&!t.webgl){const h=N(t.scale_zmin,t.scale_zmax),p=5e4;h>p&&(e=Math.max(2,Math.floor(h/p)))}const o=this.createAttMarker({attr:i,std:!1}),l=[];let m=null,x=[t.scale_zmin,t.scale_zmax],u=t.size_x3d/100*o.getFullSize();s.Circles&&(u=.06*t.size_x3d),t.usesvg&&(u*=.3);const X=t.getFrameWidth(),a=t.getFrameHeight();X>10&&a>10&&(u*=7*Math.max(t.size_x3d/X,t.size_z3d/a)),(s.Color||s.Triangles>=10)&&(x=f.getContourLevels(!0),m=f.getHistPalette()),s.Triangles&&this.drawTriangles(t,i,x,m);for(let h=0;h<x.length-1;++h){const p=Math.max(x[h],t.scale_zmin),r=Math.min(x[h+1],t.scale_zmax);if(p>=r)continue;const n=Math.floor(N(p,r)/e),w=new Int32Array(n),C=s.Markers||s.Circles?new Mt(n,t.webgl,u/3):null,Y=s.Error?new Float32Array(n*6*3):null,y=Y&&this.matchObjectType(V),c=s.Line?new Float32Array((n-1)*6):null;let _=0,k=0,M=0,P=0;for(let g=0;g<i.fNpoints;++g){if(i.fX[g]<t.scale_xmin||i.fX[g]>t.scale_xmax||i.fY[g]<t.scale_ymin||i.fY[g]>t.scale_ymax||i.fZ[g]<p||i.fZ[g]>=r||e>1&&(_=(_+1)%e,_))continue;w[k++]=g;const Z=t.grx(i.fX[g]),d=t.gry(i.fY[g]),F=t.grz(i.fZ[g]);C?.addPoint(Z,d,F),Y&&(Y[M]=t.grx(i.fX[g]-(y?i.fEXlow[g]:i.fEX[g])),Y[M+1]=d,Y[M+2]=F,Y[M+3]=t.grx(i.fX[g]+(y?i.fEXhigh[g]:i.fEX[g])),Y[M+4]=d,Y[M+5]=F,M+=6,Y[M]=Z,Y[M+1]=t.gry(i.fY[g]-(y?i.fEYlow[g]:i.fEY[g])),Y[M+2]=F,Y[M+3]=Z,Y[M+4]=t.gry(i.fY[g]+(y?i.fEYhigh[g]:i.fEY[g])),Y[M+5]=F,M+=6,Y[M]=Z,Y[M+1]=d,Y[M+2]=t.grz(i.fZ[g]-(y?i.fEZlow[g]:i.fEZ[g])),Y[M+3]=Z,Y[M+4]=d,Y[M+5]=t.grz(i.fZ[g]+(y?i.fEZhigh[g]:i.fEZ[g])),M+=6),c&&(P>=6&&(c[P]=c[P-3],c[P+1]=c[P-2],c[P+2]=c[P-1],P+=3),c[P]=Z,c[P+1]=d,c[P+2]=F,P+=3)}if(c&&P>3&&c.length===P){const g=this.getColor(i.fLineColor),Z=new H.LineBasicMaterial({color:new H.Color(g),linewidth:i.fLineWidth}),d=tt(c,Z);t.add3DMesh(d,this),d.graph=i,d.index=w,d.fp=t,d.scale0=.7*u,d.tip_name=this.getObjectHint(),d.tip_color=i.fMarkerColor===3?16711680:65280,d.nvertex=2,d.check_next=!0,d.tooltip=it}if(Y){const g=this.getColor(i.fLineColor),Z=new H.LineBasicMaterial({color:new H.Color(g),linewidth:i.fLineWidth}),d=tt(Y,Z);t.add3DMesh(d,this),d.graph=i,d.index=w,d.fp=t,d.scale0=.7*u,d.tip_name=this.getObjectHint(),d.tip_color=i.fMarkerColor===3?16711680:65280,d.nvertex=6,d.tooltip=it}if(C){let g="blue";(!s.Circles||s.Color)&&(g=m?.calcColor(h,x.length)??this.getColor(i.fMarkerColor));const Z=C.createPoints({color:g,fill:s.Circles?"white":void 0,style:s.Circles?4:i.fMarkerStyle}).then(d=>{d.graph=i,d.fp=t,d.tip_color=i.fMarkerColor===3?16711680:65280,d.scale0=.3*u,d.index=w,d.tip_name=this.getObjectHint(),d.tooltip=it,t.add3DMesh(d,this)});l.push(Z)}}return Promise.all(l).then(()=>{const h=this.getMainPainter();if(!(this.axes_draw||h?.draw_content===!1))return;const r=h?.findFunction(yt),n=this.getPadPainter()?.findPainterFor(r);if(n){if(n.Enabled=s.Zscale,s.Zscale)return n.drawPave();n.removeG()}}).then(()=>(t.render3D(100),this))}static async build3d(t,f){const i=new st(null,t);return i.decodeOptions(f,t),i.options.Contour?(console.error("Contour plot is not 3d"),null):nt.build3d(i.createHistogram(),i.options.Axis,!0).then(s=>{i.axes_draw=!0;const N=s.getFramePainter();return i.getFramePainter=()=>N,i.getMainPainter=()=>s,i.drawGraph2D().then(()=>N.create3DScene(-1,!0))})}static async draw(t,f,i){const s=new st(t,f);s.decodeOptions(i,f);let N=Promise.resolve(null);return s.getMainPainter()||(N=nt.draw(t,s.createHistogram(),s.options.Axis),s.axes_draw=!0),N.then(()=>(s.addToPadPrimitives(),s.drawGraph2D()))}}export{st as TGraph2DPainter};
