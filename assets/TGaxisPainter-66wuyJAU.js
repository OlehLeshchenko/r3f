import{az as l,m as u,b as m,a as v,E as y,a9 as d,by as X,Q as Y,e as b,V as P,bz as T}from"./index-DAa9yKAB.js";import{p as F}from"./func-CztLwFD8.js";class _ extends l{convertTo(s){const t=this.getObject(),a=this.axisToSvg("x",t.fX1),i=this.axisToSvg("y",t.fY1),e=this.axisToSvg("x",t.fX2),h=this.axisToSvg("y",t.fY2);if(s==="ndc"){const n=this.getPadPainter().getPadWidth(),r=this.getPadPainter().getPadHeight();t.fX1=a/n,t.fX2=e/n,t.fY1=(r-i)/r,t.fY2=(r-h)/r,this.use_ndc=!0}else if(s==="frame"){const n=this.getFramePainter().getFrameRect();t.fX1=(a-n.x)/n.width,t.fX2=(e-n.x)/n.width,t.fY1=(i-n.y)/n.height,t.fY2=(h-n.y)/n.height,this.bind_frame=!0}}moveDrag(s,t){this.gaxis_x+=s,this.gaxis_y+=t,u(this.getG(),this.gaxis_x,this.gaxis_y)}moveEnd(s){if(s)return;const t=this.getObject();let a,i;if(this.bind_frame){const e=this.getFramePainter().getFrameRect();a=(this.gaxis_x-e.x)/e.width,i=(this.gaxis_y-e.y)/e.height}else a=this.svgToAxis("x",this.gaxis_x,this.use_ndc),i=this.svgToAxis("y",this.gaxis_y,this.use_ndc);this.vertical?(t.fX1=t.fX2=a,this.reverse?(t.fY2=i+(t.fY2-t.fY1),t.fY1=i):(t.fY1=i+(t.fY1-t.fY2),t.fY2=i)):(this.reverse?(t.fX1=a+(t.fX1-t.fX2),t.fX2=a):(t.fX2=a+(t.fX2-t.fX1),t.fX1=a),t.fY1=t.fY2=i),this.submitAxisExec(`SetX1(${t.fX1});;SetX2(${t.fX2});;SetY1(${t.fY1});;SetY2(${t.fY2})`,!0)}redraw(){const s=this.getObject(),t=s.fWmin,a=s.fWmax;let i,e,h,n;if(this.bind_frame){const f=this.getFramePainter().getFrameRect();i=Math.round(f.x+s.fX1*f.width),h=Math.round(f.x+s.fX2*f.width),e=Math.round(f.y+s.fY1*f.height),n=Math.round(f.y+s.fY2*f.height)}else i=this.axisToSvg("x",s.fX1,this.use_ndc),e=this.axisToSvg("y",s.fY1,this.use_ndc),h=this.axisToSvg("x",s.fX2,this.use_ndc),n=this.axisToSvg("y",s.fY2,this.use_ndc);const r=h-i,c=e-n,o=Math.abs(r)<Math.abs(c);let x=o?c:r,g=!1;return x<0&&(g=!0,x=-x,o?n=e:i=h),this.configureAxis(o?"yaxis":"xaxis",t,a,t,a,o,[0,x],{time_scale:s.fChopt.indexOf("t")>=0,log:s.fChopt.indexOf("G")>=0?1:0,reverse:g,swap_side:g,axis_func:this.axis_func}),this.gaxis_x=i,this.gaxis_y=n,this.drawAxis(this.createG(),Math.abs(r),Math.abs(c),u(this.gaxis_x,this.gaxis_y)||"").then(()=>(m(this),v(this,P),this))}fillContextMenuItems(s){s.addTAxisMenu(y,this,this.getObject(),"")}async checkFuncion(){const s=this.getObject();if(!s.fFunctionName){this.axis_func=null;return}const t=this.getPadPainter()?.findInPrimitives(s.fFunctionName,d);let a=Promise.resolve(t);if(!t){const i=T(),e=i?.findItem({name:s.fFunctionName,check_keys:!0});e&&(a=i.getObject({item:e}).then(h=>h?.obj?._typename===d?h.obj:null))}return a.then(i=>{this.axis_func=i,i&&F(i)})}createFuncHandle(s,t,a,i){const e=function(r){return e.toGraph(r)};e._func=s,e._domain=[a,i],e._scale=t?X().base(t):Y(),e._scale.domain(e._domain).range([0,100]),e.eval=function(r){try{r=e._func.evalPar(r)}catch{r=0}return Number.isFinite(r)?r:0};const h=e.eval(a),n=e.eval(i);return h<n==a<i?(e._vmin=h,e._vk=1/(n-h)):h===n?(e._vmin=0,e._vk=1):(e._vmin=n,e._vk=1/(h-n)),e._range=[0,100],e.range=function(r){return r?(e._range=r,e):e._range},e.domain=function(){return e._domain},e.toGraph=function(r){const c=(e.eval(r)-e._vmin)*e._vk;return e._range[0]*(1-c)+e._range[1]*c},e.ticks=function(r){return e._scale.ticks(r)},e}static async draw(s,t,a){const i=new _(s,t,!1);return b(i,!1).then(()=>(a&&i.convertTo(a),i.checkFuncion())).then(()=>i.redraw())}}export{_ as TGaxisPainter};
