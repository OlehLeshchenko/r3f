import{aV as Ct,Y as Lt,aF as Vt,i as _t,aB as kt,a5 as Rt,a6 as ct,n as et,aH as Ot,aD as Yt,m as Tt,K as Dt,N as Wt,a as Zt,b3 as Ut,b4 as qt,b5 as Kt,b2 as Ht,p as Gt,ab as zt,E as Jt,b6 as Qt,b7 as te,b8 as ee}from"./index-DAa9yKAB.js";import{T as Nt,a as ie}from"./THistPainter-DJAmNO-k.js";function ne(mt,t,i,e,n){const a=new Float32Array(4008),r=new Float32Array(2*2004),d=new Int32Array(2*2004),g=i.length,$=i[0],s=i[g-1],h=[],p=[0,0,0,0],l=[0,0,0,0],o=[0,0,0,0],f=[0,0,0,0],m=t.grx,P=t.gry;let _=0;const T=J=>{if(J>=s)return g-1;for(let Y=0;Y<g;++Y)if(J<i[Y])return Y-1;return g-1},u=J=>{if(J<$)return-1;if(J>=s)return g-1;let Y=0,D=g-1,z;for(;D-Y>1;)z=Math.round((D+Y)/2),J<i[z]?D=z:Y=z;return Y},C=g<10?T:u,B=(J,Y,D,z,dt,Mt,lt,nt)=>{const S=D===lt,X=S?nt-z:lt-D,L=dt-J;let R=Y+1,O=_-1,E=0,F,V,ut,gt;const pt=O+2004/2-3;for(;R<=Mt&&O<=pt;)gt=i[R],ut=gt-J,V=ut/L,F=X*V,S?(a[O]=D,r[O]=z+F):(a[O]=D+F,r[O]=z),d[O]=R,E++,O+=2,R++;return E};let M,b,x=0,y,H,w,A,j,I,v,N,G,Q,U,at;for(H=t.j1;H<t.j2-1;++H)for(l[1]=l[0]=(P[H]+P[H+1])/2,l[3]=l[2]=(P[H+1]+P[H+2])/2,y=t.i1;y<t.i2-1;++y){for(o[0]=mt.getBinContent(y+1,H+1),o[1]=mt.getBinContent(y+2,H+1),o[2]=mt.getBinContent(y+2,H+2),o[3]=mt.getBinContent(y+1,H+2),w=0;w<4;w++)f[w]=C(o[w]);if(f[0]!==f[1]||f[1]!==f[2]||f[2]!==f[3]||f[3]!==f[0]){for(p[3]=p[0]=(m[y]+m[y+1])/2,p[2]=p[1]=(m[y+1]+m[y+2])/2,j=o[0]<=o[1]?0:1,A=o[2]<=o[3]?2:3,o[j]>o[A]&&(j=A),j++,_=1,U=1;U<=4;U++)A=j%4+1,I=B(o[j-1],f[j-1],p[j-1],l[j-1],o[A-1],f[A-1],p[A-1],l[A-1]),_+=2*I,j=A;for(j=o[0]<=o[1]?0:1,A=o[2]<=o[3]?2:3,o[j]>o[A]&&(j=A),j++,_=2,U=1;U<=4;U++)A=j===1?4:j-1,I=B(o[j-1],f[j-1],p[j-1],l[j-1],o[A-1],f[A-1],p[A-1],l[A-1]),_+=2*I,j=A;for(v=0,U=1;U<=_-5;U+=2)for(;d[U-1]!==d[U];){for(N=a[U],G=r[U],Q=d[U],at=U;at<=_-5;at+=2)a[at]=a[at+2],r[at]=r[at+2],d[at]=d[at+2];if(a[_-3]=N,r[_-3]=G,d[_-3]=Q,v>2e3)break;v++}if(v>100)continue;for(U=1;U<=_-2;U+=2)if(M=d[U-1],M>=0&&M<i.length){b=h[M],b||(b=h[M]=ee(2004*4,!0));const J=b.fLastPoint;J<b.fN-2&&(b.fX[J+1]=Math.round(a[U-1]),b.fY[J+1]=Math.round(r[U-1]),b.fX[J+2]=Math.round(a[U]),b.fY[J+2]=Math.round(r[U]),b.fLastPoint=J+2,x=Math.max(x,b.fLastPoint+1))}}}const q=new Int32Array(i.length);let W=0;for(M=0;M<i.length;M++)if(i[M]>=0){W=M;break}for(w=0,M=W-1;M>=0;M--)q[w++]=M;for(M=W;M<i.length;M++)q[w++]=M;const Z=new Float32Array(2*x),K=new Float32Array(2*x),tt=_t(e.calcColorIndex);for(w=0;w<i.length;++w){if(M=q[w],b=h[M],!b)continue;const J=tt?e.calcColorIndex(M,i.length):M,Y=b.fX,D=b.fY,z=b.fLastPoint+1,dt=0,Mt=0;let lt=0,nt,S,X;for(;;){for(nt=x,S=nt+1,Z[nt]=Y[lt],K[nt]=D[lt],Z[S]=Y[lt+1],K[S]=D[lt+1],Y[lt]=Y[lt+1]=dt,D[lt]=D[lt+1]=Mt;;){for(X=0,y=2;y<z;y+=2)S<2*x-1&&Y[y]===Z[S]&&D[y]===K[S]&&(S++,Z[S]=Y[y+1],K[S]=D[y+1],Y[y]=Y[y+1]=dt,D[y]=D[y+1]=Mt,X++),nt>0&&Y[y+1]===Z[nt]&&D[y+1]===K[nt]&&(nt--,Z[nt]=Y[y],K[nt]=D[y],Y[y]=Y[y+1]=dt,D[y]=D[y+1]=Mt,X++);if(X===0)break}for(nt+1<S&&nt>=0&&n(J,Z,K,nt,S,M),lt=0,y=2;y<z;y+=2)if(Y[y]!==dt&&D[y]!==Mt){lt=y;break}if(lt===0)break}}}class re{constructor(t,i,e,n,c,k,a){let r=[e,n];if(t){r=new Float32Array(t.length);for(let y=0;y<t.length;++y)r[y]=i(t[y])}Object.assign(this,{grz_min:e,grz_max:n,dolines:c,donormals:k,dogrid:a}),this.loop=0;const d=[],g=[],$=[],s=new Float32Array(18),h=new Float32Array(6),p=(r.at(-1)-r.at(0))/r.length/100;let l=0,o=null,f=0,m=0,P=null,_=0,T=[],u=0,C=0,B=0;function M(y,H,w,A){return y<H-A?-1:y>w+A?1:0}this.createNormIndex=function(y){y.donormals&&(T=new Int32Array((y.i2-y.i1)*(y.j2-y.j1)*8).fill(-1))},this.createBuffers=function(){if(this.loop){for(let y=1;y<r.length;++y)d[y]&&(g[y]=new Float32Array(d[y]*9),$[y]=0);this.dolines&&l>0&&(o=new Float32Array(l*6)),this.dogrid&&m>0&&(P=new Float32Array(m*6))}},this.addLineSegment=function(y,H,w,A,j,I){if(!this.dolines)return;const v=M(w,this.grz_min,this.grz_max,0),N=M(I,this.grz_min,this.grz_max,0);if(!(v===N&&v)){if(!this.loop)return++l;if(v){const G=I-w;w=v<0?this.grz_min:this.grz_max,y=A-(A-y)/G*(I-w),H=j-(j-H)/G*(I-w)}if(N){const G=w-I;I=N<0?this.grz_min:this.grz_max,A=y-(y-A)/G*(w-I),j=H-(H-j)/G*(w-I)}o[f]=y,o[f+1]=H,o[f+2]=w,f+=3,o[f]=A,o[f+1]=j,o[f+2]=I,f+=3}};function b(y,H,w,A,j,I,v,N){u>=s.length&&console.log("more than 6 points???");const G=(v-w)/(I-w);let Q=3;C&&Math.abs(G)<Math.abs(C)&&(s[u]=s[u-3],s[u+1]=s[u-2],s[u+2]=s[u-1],u-=3,Q=6),s[u]=y+G*(A-y),s[u+1]=H+G*(j-H),s[u+2]=v,N&&P&&(h[B]=s[u],h[B+1]=s[u+1],h[B+2]=s[u+2],B+=3),u+=Q,C=G}function x(y,H,w,A){const j=((w-H.i1)*(H.j2-H.j1)+(A-H.j1))*8;if(T[j]>=0)return console.error("More than 8 vertexes for the bin");const I=j+8+T[j];T[j]--,T[I]=y}this.addMainTriangle=function(y,H,w,A,j,I,v,N,G,Q,U,at,q){for(let W=1;W<r.length;++W){let Z=M(w,r[W-1],r[W],p),K=M(I,r[W-1],r[W],p),tt=M(G,r[W-1],r[W],p),J=Z+K+tt;if(W>1&&W===r.length-1&&J===3&&w<=this.grz_max&&(Z=K=tt=J=0),J===3)continue;if(J===-3)return;if(!this.loop){let z=Math.abs(K-Z)+Math.abs(tt-K)+Math.abs(Z-tt);Z===0&&++z,K===0&&++z,tt===0&&++z,(z===1||z===2)&&console.error(`FOUND npnts = ${z}`),z>2&&(d[W]===void 0&&(d[W]=0),d[W]+=z-2),(Z>0||K>0||tt>0)&&(Z!==K||K!==tt||tt!==Z)&&++m;continue}if(B=0,u=0,Z===0&&(s[u]=y,s[u+1]=H,s[u+2]=w,u+=3),Z!==K&&(C=0,(Z<0||K<0)&&b(y,H,w,A,j,I,r[W-1]),(Z>0||K>0)&&b(y,H,w,A,j,I,r[W],!0)),K===0&&(s[u]=A,s[u+1]=j,s[u+2]=I,u+=3),K!==tt&&(C=0,(K<0||tt<0)&&b(A,j,I,v,N,G,r[W-1]),(K>0||tt>0)&&b(A,j,I,v,N,G,r[W],!0)),tt===0&&(s[u]=v,s[u+1]=N,s[u+2]=G,u+=3),tt!==Z&&(C=0,(tt<0||Z<0)&&b(v,N,G,y,H,w,r[W-1]),(tt>0||Z>0)&&b(v,N,G,y,H,w,r[W],!0)),u===0)continue;if(u<9){console.log(`found ${u/3} points, must be at least 3`);continue}if(P&&B===6){for(let z=0;z<6;++z)P[_+z]=h[z];_+=6}const Y=g[W];let D=$[W];this.donormals&&u===9&&(x(D,U,at,q),x(D+3,U,at+1,Q?q+1:q),x(D+6,U,Q?at:at+1,q+1));for(let z=3;z<u-3;z+=3)Y[D]=s[0],Y[D+1]=s[1],Y[D+2]=s[2],D+=3,Y[D]=s[z],Y[D+1]=s[z+1],Y[D+2]=s[z+2],D+=3,Y[D]=s[z+3],Y[D+1]=s[z+4],Y[D+2]=s[z+5],D+=3;$[W]=D}},this.callFuncs=function(y,H){for(let w=1;w<r.length;++w)g[w]&&y&&y(w,g[w],T);o&&H&&(l*6!==f&&console.error(`SURF lines mismmatch nsegm=${l} lindx=${f} diff=${l*6-f}`),H(!1,o)),P&&H&&(m*6!==_&&console.error(`SURF grid draw mismatch ngridsegm=${m} gindx=${_} diff=${m*6-_}`),H(!0,P))}}}function se(mt,t,i,e,n){const c=t.grz,k=t.original?t.origx:t.grx,a=t.original?t.origy:t.gry,r=new re(i,t.grz,t.grz_min,t.grz_max,t.dolines,t.donormals,t.dogrid);let d,g,$,s,h,p,l,o,f,m;for(r.createNormIndex(t),r.loop=0;r.loop<2;++r.loop)for(r.createBuffers(),d=t.i1;d<t.i2-1;++d)for($=t.original?.5*(k[d]+k[d+1]):k[d],s=t.original?.5*(k[d+1]+k[d+2]):k[d+1],g=t.j1;g<t.j2-1;++g)h=t.original?.5*(a[g]+a[g+1]):a[g],p=t.original?.5*(a[g+1]+a[g+2]):a[g+1],l=c(mt.getBinContent(d+1,g+1)),o=c(mt.getBinContent(d+1,g+2)),f=c(mt.getBinContent(d+2,g+1)),m=c(mt.getBinContent(d+2,g+2)),r.addMainTriangle($,h,l,s,p,m,$,p,o,!0,t,d,g),r.addMainTriangle($,h,l,s,h,f,s,p,m,!1,t,d,g),r.addLineSegment($,p,o,$,h,l),r.addLineSegment($,h,l,s,h,f),d===t.i2-2&&r.addLineSegment(s,h,f,s,p,m),g===t.j2-2&&r.addLineSegment($,p,o,s,p,m);r.callFuncs(e,n)}let le=class Et extends Nt{#t;#i;#n;#s;#r;#e;get _wheel_zoomy(){return!0}cleanup(){delete this.tt_handle,this.#e=void 0,super.cleanup()}getHisto(){const t=super.getHisto();if(t?._typename===Ct)switch(t.$getBinContent||(t.$getBinContent=t.getBinContent),this.getOptions().Profile2DProj){case"B":t.getBinContent=t.getBinEntries;break;case"C=E":t.getBinContent=function(i,e){return this.getBinError(this.getBin(i,e))};break;case"W":t.getBinContent=function(i,e){return this.$getBinContent(i,e)*this.getBinEntries(i,e)};break;default:t.getBinContent=t.$getBinContent;break}return t}isProjection(){return this.#t}toggleProjection(t,i){(t==="Projections"||t==="Off")&&(t="");const e=a=>{if(a==="all"||a==="ALL")return 1e4;const r=parseInt(a);return r&&Number.isInteger(r)?r:1};let n=i,c=i;if(Lt(t)&&t.indexOf("XY")===0){const a=t.length>2?t.slice(2):"";t="XY",n=c=parseInt(a)||1}else if(Lt(t)&&t.length>1){const a=t.indexOf("_");a>0&&t[0]==="X"&&t[a+1]==="Y"?(n=e(t.slice(1,a)),c=e(t.slice(a+2)),t="XY"):a>0&&t[0]==="Y"&&t[a+1]==="X"?(c=e(t.slice(1,a)),n=e(t.slice(a+2)),t="XY"):(n=c=e(t.slice(1)),t=t[0])}if(!n&&!c&&(n=c=1),t&&this.#t===t)if(this.#i===n&&this.#n===c)t="";else{this.#i=n,this.#n=c;return}delete this.proj_hist;const k=this.#t===t?"":t;return this.#i=n,this.#n=c,this.#t="",this.provideSpecialDrawArea(k).then(()=>(this.#t=k,this.redrawProjection()))}async redrawProjection(t,i,e,n){if(!this.#t)return!1;if(n===void 0){if(!this.tt_handle)return;t=Math.round((this.tt_handle.i1+this.tt_handle.i2)/2),i=t+1,e=Math.round((this.tt_handle.j1+this.tt_handle.j2)/2),n=e+1}const c=this.getCanvPainter();if(c&&!c.isReadonly()&&this.hasSnapId())return(this.#t==="X"||this.#t==="XY")&&!c.websocketTimeout("projX")&&c.sendWebsocket(`EXECANDSEND:DXPROJ:${this.getSnapId()}:ProjectionX("_projx",${e+1},${n},"")`)&&c.websocketTimeout("projX",1e3),(this.#t==="Y"||this.#t==="XY")&&!c.websocketTimeout("projY")&&c.sendWebsocket(`EXECANDSEND:DYPROJ:${this.getSnapId()}:ProjectionY("_projy",${t+1},${i},"")`)&&c.websocketTimeout("projY",1e3),!0;if(this.doing_projection)return!1;this.doing_projection=!0;const k=this.getHisto(),a=()=>{const g=Gt(zt,this.nbinsx);return Object.assign(g.fXaxis,k.fXaxis),g.fName="xproj",g.fTitle="X projection",g},r=()=>{const g=Gt(zt,this.nbinsy);return Object.assign(g.fXaxis,k.fYaxis),g.fName="yproj",g.fTitle="Y projection",g},d=(g,$)=>{let s=0,h=-1;if(g==="X"){for(let p=0;p<this.nbinsx;++p){let l=0;for(let o=e;o<n;++o)l+=k.getBinContent(p+1,o+1);$.setBinContent(p+1,l)}$.fTitle="X projection "+(e+1===n?`bin ${n}`:`bins [${e+1} .. ${n}]`),this.tt_handle&&(s=this.tt_handle.i1+1,h=this.tt_handle.i2)}else{for(let p=0;p<this.nbinsy;++p){let l=0;for(let o=t;o<i;++o)l+=k.getBinContent(o+1,p+1);$.setBinContent(p+1,l)}$.fTitle="Y projection "+(t+1===i?`bin ${i}`:`bins [${t+1} .. ${i}]`),this.tt_handle&&(s=this.tt_handle.j1+1,h=this.tt_handle.j2)}s<h&&($.fXaxis.fFirst=s,$.fXaxis.fLast=h,$.fXaxis.SetBit(Jt.kAxisRange,s!==1||h!==$.fXaxis.fNbins)),$.fEntries=0,$.fTsumw=0};if(!this.proj_hist)switch(this.#t){case"X":this.proj_hist=a();break;case"XY":this.proj_hist=a(),this.proj_hist2=r();break;default:this.proj_hist=r()}return this.#t==="XY"?(d("X",this.proj_hist),d("Y",this.proj_hist2),this.drawInSpecialArea(this.proj_hist,"","X").then(()=>this.drawInSpecialArea(this.proj_hist2,"","Y")).then(g=>(delete this.doing_projection,g))):(d(this.#t,this.proj_hist),this.drawInSpecialArea(this.proj_hist).then(g=>(delete this.doing_projection,g)))}executeMenuCommand(t,i){return super.executeMenuCommand(t,i)?!0:t.fName==="SetShowProjectionX"||t.fName==="SetShowProjectionY"?(this.toggleProjection(t.fName[17],i&&parseInt(i)?parseInt(i):1),!0):t.fName==="SetShowProjectionXY"?(this.toggleProjection("X"+i.replaceAll(",","_Y")),!0):!1}fillHistContextMenu(t){if(!this.isTH2Poly()&&this.getPadPainter()?.isCanvas()){let n=this.#t||"";n&&(n+=this.#i),this.#i!==this.#n&&this.#t==="XY"&&(n=`X${this.#i}_Y${this.#n}`);const c=["1","2","3","5","10","all"];n&&c.unshift(""),t.sub("Projections",()=>t.input("Input projection kind X1 or XY2 or X3_Y4",n,"string").then(k=>this.toggleProjection(k))),["X","Y","XY"].forEach(k=>{t.column(),c.forEach(a=>{const r=a?k+a:"Off";t.addchk(n===r,r,r,d=>this.toggleProjection(d))}),t.endcolumn()}),t.endsub()}this.isTH2Poly()||t.add("Auto zoom-in",()=>this.autoZoom());const i=this.getSupportedDrawOptions(),e=this.getOptions();t.addDrawMenu("Draw with",i,n=>{if(n.indexOf(Vt)===0)return this.showInspector(n);const c=e.Project;this.decodeOptions(n),c===e.Project||this.mode3d?this.interactiveRedraw("pad","drawopt"):this.toggleProjection(e.Project)}),(e.Color||e.Contour||e.Hist||e.Surf||e.Lego===12||e.Lego===14)&&this.fillPaletteMenu(t,!0)}clickButton(t){const i=super.clickButton(t);if(i)return i;if(this.isMainPainter())switch(t){case"ToggleColor":return this.toggleColor();case"Toggle3D":return this.toggleMode3D()}return!1}fillToolbar(){super.fillToolbar(!0);const t=this.getPadPainter(),i=this.getOptions();t&&(!this.isTH2Poly()&&!i.Axis&&t.addPadButton("th2color","Toggle color","ToggleColor"),i.Axis||t.addPadButton("th2colorz","Toggle color palette","ToggleColorZ"),t.addPadButton("th2draw3d","Toggle 3D mode","Toggle3D"),t.showPadButtons())}toggleColor(){const t=this.getOptions();return t.Mode3D?(t.Mode3D=!1,t.Color=!0):(t.Color=!t.Color,t.Scat=!t.Color),this.#s=!0,this.copyOptionsToOthers(),this.interactiveRedraw("pad","drawopt")}autoZoom(){if(this.isTH2Poly())return;const t=this.getSelectIndex("x","left",-1),i=this.getSelectIndex("x","right",1),e=this.getSelectIndex("y","left",-1),n=this.getSelectIndex("y","right",1),c=this.getHisto();if(t===i||e===n)return;let k=c.getBinContent(t+1,e+1);for(let o=t;o<i;++o)for(let f=e;f<n;++f)k=Math.min(k,c.getBinContent(o+1,f+1));if(k>0)return;let a=i,r=t,d=n,g=e;for(let o=t;o<i;++o)for(let f=e;f<n;++f)c.getBinContent(o+1,f+1)>k&&(o<a&&(a=o),o>=r&&(r=o+1),f<d&&(d=f),f>=g&&(g=f+1));let $,s,h,p,l=!1;if(a===r-1&&a>t+1&&r<i-1&&(a--,r++),d===g-1&&d>e+1&&g<n-1&&(d--,g++),(a>t||r<i)&&a<r-1&&($=c.fXaxis.GetBinLowEdge(a+1),s=c.fXaxis.GetBinLowEdge(r+1),l=!0),(d>e||g<n)&&d<g-1&&(h=c.fYaxis.GetBinLowEdge(d+1),p=c.fYaxis.GetBinLowEdge(g+1),l=!0),l)return this.getFramePainter()?.zoom($,s,h,p)}scanContent(t){if(t&&this.nbinsx&&this.nbinsy)return;const i=this.getObject(),e=this.getOptions();let n,c;if(this.extractAxesProperties(2),this.isTH2Poly()){this.gminposbin=null,this.gminbin=this.gmaxbin=0;for(let a=0,r=i.fBins.arr.length;a<r;++a){const d=i.fBins.arr[a].fContent;a===0&&(this.gminbin=this.gmaxbin=d),d<this.gminbin?this.gminbin=d:d>this.gmaxbin&&(this.gmaxbin=d),d>0&&(this.gminposbin===null||this.gminposbin>d)&&(this.gminposbin=d)}}else for(this.gminbin=this.gmaxbin=i.getBinContent(1,1),this.gminposbin=null,n=0;n<this.nbinsx;++n)for(c=0;c<this.nbinsy;++c){const a=i.getBinContent(n+1,c+1);a<this.gminbin?this.gminbin=a:a>this.gmaxbin&&(this.gmaxbin=a),a>0&&(this.gminposbin===null||this.gminposbin>a)&&(this.gminposbin=a)}this.gminposbin===null&&this.gmaxbin>0&&(this.gminposbin=this.gmaxbin*1e-4);let k=this.gmaxbin||this.gminbin;if(!k&&i._typename===Ct){for(n=0;n<this.nbinsx&&!k;++n)for(c=0;c<this.nbinsy;++c)if(i.getBinEntries(n+1,c+1)){k=!0;break}}e.Axis>0?this.draw_content=!1:this.isTH2Poly()?(this.draw_content=k||e.Line||e.Fill||e.Mark,!this.draw_content&&e.Zero&&(this.draw_content=!0,e.Line=1)):this.draw_content=k||e.ShowEmpty}getUserRanges(){const t=this.getHisto();return{minx:t.fXaxis.fXmin,maxx:t.fXaxis.fXmax,miny:t.fYaxis.fXmin,maxy:t.fYaxis.fXmax}}countStat(t,i){const e=this.getHisto(),n=this.getOptions(),c=e.fXaxis,k=e.fYaxis,a=this.getHistGrFuncs(),r={name:e.fName,entries:0,eff_entries:0,integral:0,meanx:0,meany:0,rmsx:0,rmsy:0,matrix:[0,0,0,0,0,0,0,0,0],xmax:0,ymax:0,wmax:null,skewx:0,skewy:0,skewd:0,kurtx:0,kurty:0,kurtd:0},d=!a.isAxisZoomed("x")&&!a.isAxisZoomed("y")&&Math.abs(e.fTsumw)>1e-300&&!t&&!n.cutg;let g=0,$=0,s=0,h=0,p=0,l=0,o,f,m,P,_,T,u,C,B;if(!_t(t)&&n.cutg&&(t=(M,b)=>n.cutg.IsInside(M,b)),this.isTH2Poly()){const M=e.fBins.arr.length;let b,x,y,H,w,A,j;for(b=0;b<M;++b){for(x=e.fBins.arr[b],o=x.fXmin>a.scale_xmax?2:x.fXmax<a.scale_xmin?0:1,f=x.fYmin>a.scale_ymax?2:x.fYmax<a.scale_ymin?0:1,m=P=j=0,H=x.fPoly,A=1,H._typename===kt&&(A=x.fPoly.fGraphs.arr.length,H=null),w=0;w<A;++w)for((!H||w>0)&&(H=x.fPoly.fGraphs.arr[w]),y=0;y<H.fNpoints;++y)++j,m+=H.fX[y],P+=H.fY[y];j>1&&(m/=j,P/=j),_=x.fContent,r.entries+=_,r.matrix[f*3+o]+=_,!(o!==1||f!==1||t&&!t(m,P))&&((r.wmax===null||_>r.wmax)&&(r.wmax=_,r.xmax=m,r.ymax=P),d||(g+=_,$+=_*_,s+=m*_,h+=P*_,p+=m*m*_,l+=P*P*_))}}else{T=this.getSelectIndex("x","left"),u=this.getSelectIndex("x","right"),C=this.getSelectIndex("y","left"),B=this.getSelectIndex("y","right");for(let M=0;M<=this.nbinsx+1;++M){o=M<=T?0:M>u?2:1,m=c.GetBinCoord(M-.5);for(let b=0;b<=this.nbinsy+1;++b)f=b<=C?0:b>B?2:1,P=k.GetBinCoord(b-.5),_=e.getBinContent(M,b),r.entries+=_,r.matrix[f*3+o]+=_,!(o!==1||f!==1||t&&!t(m,P))&&((r.wmax===null||_>r.wmax)&&(r.wmax=_,r.xmax=m,r.ymax=P),d||(g+=_,$+=_*_,s+=m*_,h+=P*_,p+=m**2*_,l+=P**2*_))}}if(d&&(g=e.fTsumw,$=e.fTsumw2,s=e.fTsumwx,p=e.fTsumwx2,h=e.fTsumwy,l=e.fTsumwy2),Math.abs(g)>1e-300&&(r.meanx=s/g,r.meany=h/g,r.rmsx=Math.sqrt(Math.abs(p/g-r.meanx**2)),r.rmsy=Math.sqrt(Math.abs(l/g-r.meany**2))),r.wmax===null&&(r.wmax=0),r.integral=g,e.fEntries>0&&(r.entries=e.fEntries),r.eff_entries=$?g*g/$:Math.abs(g),i&&!this.isTH2Poly()){let M=0,b=0,x=0,y=0,H=0,w;for(let N=T;N<u;++N){m=c.GetBinCoord(N+.5);for(let G=C;G<B;++G)P=k.GetBinCoord(G+.5),!(t&&!t(m,P))&&(w=e.getBinContent(N+1,G+1),H+=w,M+=w*Math.pow(m-r.meanx,3),b+=w*Math.pow(P-r.meany,3),x+=w*Math.pow(m-r.meanx,4),y+=w*Math.pow(P-r.meany,4))}const A=Math.pow(r.rmsx,3),j=Math.pow(r.rmsy,3),I=Math.pow(r.rmsx,4),v=Math.pow(r.rmsy,4);H*A&&(r.skewx=M/(H*A)),H*j&&(r.skewy=b/(H*j)),r.skewd=r.eff_entries>0?Math.sqrt(6/r.eff_entries):0,H*I&&(r.kurtx=x/(H*I)-3),H*v&&(r.kurty=y/(H*v)-3),r.kurtd=r.eff_entries>0?Math.sqrt(24/r.eff_entries):0}return r}fillStatistic(t,i,e){if(this.isIgnoreStatsFill())return!1;i===1&&(i=1111);const n=Math.floor(i%10),c=Math.floor(i/10)%10,k=Math.floor(i/100)%10,a=Math.floor(i/1e3)%10,r=Math.floor(i/1e4)%10,d=Math.floor(i/1e5)%10,g=Math.floor(i/1e6)%10,$=Math.floor(i/1e7)%10,s=Math.floor(i/1e8)%10,h=this.countStat(void 0,$>0||s>0);if(t.clearPave(),n>0&&t.addText(h.name),c>0&&t.addText("Entries = "+t.format(h.entries,"entries")),k>0&&(t.addText("Mean x = "+t.format(h.meanx)),t.addText("Mean y = "+t.format(h.meany))),a>0&&(t.addText("Std Dev x = "+t.format(h.rmsx)),t.addText("Std Dev y = "+t.format(h.rmsy))),g>0&&t.addText("Integral = "+t.format(h.matrix[4],"entries")),$===2?(t.addText(`Skewness x = ${t.format(h.skewx)} #pm ${t.format(h.skewd)}`),t.addText(`Skewness y = ${t.format(h.skewy)} #pm ${t.format(h.skewd)}`)):$>0&&(t.addText(`Skewness x = ${t.format(h.skewx)}`),t.addText(`Skewness y = ${t.format(h.skewy)}`)),s===2?(t.addText(`Kurtosis x = ${t.format(h.kurtx)} #pm ${t.format(h.kurtd)}`),t.addText(`Kurtosis y = ${t.format(h.kurty)} #pm ${t.format(h.kurtd)}`)):s>0&&(t.addText(`Kurtosis x = ${t.format(h.kurtx)}`),t.addText(`Kurtosis y = ${t.format(h.kurty)}`)),r>0||d>0){const p=l=>h.matrix[l].toFixed(0);t.addText(`${p(6)} | ${p(7)} | ${p(7)}`),t.addText(`${p(3)} | ${p(4)} | ${p(5)}`),t.addText(`${p(0)} | ${p(1)} | ${p(2)}`)}return e&&t.fillFunctionStat(this.findFunction(Rt),e,2),!0}drawBinsColor(){const t=this.getHisto(),i=this.getOptions(),e=this.prepareDraw(),n=this.getContour(),c=this.getHistPalette(),k=[],a=t.fSumw2?.length,r=i.ShowEmpty,d=i.Color!==7||e.xbar1===0&&e.xbar2===1,g=i.Color!==7||e.ybar1===0&&e.ybar2===1,$=n.getPaletteIndex(c,0);let s,h,p,l,o,f,m,P=null,_=!i.Zero,T;const u=i.cutg,C=()=>{P.path+=`h${s}v${P.y1-P.y2}h${-s}z`,P=null};!_&&!r&&$===null&&(_=!0),_&&t?._typename===Ct&&(_=1);for(let B=e.i1;B<e.i2;++B){s=e.grx[B+1]-e.grx[B]||1,d?p=e.grx[B]:(p=Math.round(e.grx[B]+s*e.xbar1),s=Math.round(s*(e.xbar2-e.xbar1))||1);for(let M=e.j2-1;M>=e.j1;--M){if(o=t.getBinContent(B+1,M+1),f=o===0&&(!a||t.fSumw2[t.getBin(B+1,M+1)]===0),T=f&&(_===1?!t.getBinEntries(B+1,M+1):_),T||u&&!u.IsInside(t.fXaxis.GetBinCoord(B+.5),t.fYaxis.GetBinCoord(M+.5))){P&&C();continue}if(m=n.getPaletteIndex(c,o),m===null)if(f&&(r||_===1))m=$||0;else{P&&C();continue}h=e.gry[M]-e.gry[M+1]||1,g?l=e.gry[M+1]:(l=Math.round(e.gry[M]-h*e.ybar2),h=Math.round(h*(e.ybar2-e.ybar1))||1);const b=`M${p},${l}`;let x=k[m];if(!x)x=k[m]={path:b};else if(g&&x===P){x.y1=l+h;continue}else{const y=p-x.x1,H=l-x.y2;if(y||H){const w=`m${y},${H}`;x.path+=w.length<b.length?w:b}}P&&C(),x.x1=p,x.y2=l,g?(x.y1=l+h,P=x):x.path+=`h${s}v${h}h${-s}z`}P&&C()}return k.forEach((B,M)=>{B&&this.appendPath(B.path).attr("fill",c.getColor(M))}),e}drawBinsPolar(){const t=this.getHisto(),i=this.getOptions(),e=this.prepareDraw(),n=this.getContour(),c=this.getHistPalette(),k=[],a=t.fSumw2?.length,r=i.ShowEmpty,d=n.getPaletteIndex(c,0);let g,$,s,h=!i.Zero,p;const l=i.cutg;!h&&!r&&d===null&&(h=!0),h&&t?._typename===Ct&&(h=1),e.getBinPath=function(o,f){const m=2*Math.PI*Math.max(0,this.grx[o])/this.width,P=2*Math.PI*Math.min(this.grx[o+1],this.width)/this.width,_=Math.min(this.gry[f],this.height)/this.height,T=Math.max(0,this.gry[f+1])/this.height,u=P-m>Math.PI?1:0;if(P<=m||_<=T)return"";const C=this.width/2,B=this.height/2,M=T*this.width/2,b=_*this.width/2,x=T*this.height/2,y=_*this.height/2,H=C+M*Math.cos(m),w=C+M*Math.cos(P),A=B+x*Math.sin(m),j=B+x*Math.sin(P),I=C+b*Math.cos(m),v=C+b*Math.cos(P),N=B+y*Math.sin(m),G=B+y*Math.sin(P);return`M${H.toFixed(2)},${A.toFixed(2)}A${M.toFixed(2)},${x.toFixed(2)},0,${u},1,${w.toFixed(2)},${j.toFixed(2)}L${v.toFixed(2)},${G.toFixed(2)}A${b.toFixed(2)},${y.toFixed(2)},0,${u},0,${I.toFixed(2)},${N.toFixed(2)}Z`},e.findBin=function(o,f){const m=this.width/2,P=this.height/2;let _=Math.atan2((f-P)/this.height,(o-m)/this.width),T,u;const C=Math.abs(Math.cos(_))>.5?(o-m)/Math.cos(_)/this.width*2:(f-P)/Math.sin(_)/this.height*2;for(_<0&&(_+=2*Math.PI),T=this.i1;T<this.i2;++T){const B=2*Math.PI*this.grx[T]/this.width,M=2*Math.PI*this.grx[T+1]/this.width;if(B<=_&&_<=M)break}for(u=this.j1;u<this.j2;++u){const B=this.gry[u]/this.height;if(this.gry[u+1]/this.height<=C&&C<=B)break}return{i:T,j:u}};for(let o=e.i1;o<e.i2;++o)for(let f=e.j2-1;f>=e.j1;--f){if(g=t.getBinContent(o+1,f+1),$=g===0&&(!a||t.fSumw2[t.getBin(o+1,f+1)]===0),p=$&&(h===1?!t.getBinEntries(o+1,f+1):h),p||l&&!l.IsInside(t.fXaxis.GetBinCoord(o+.5),t.fYaxis.GetBinCoord(f+.5)))continue;if(s=n.getPaletteIndex(c,g),s===null)if($&&(r||h===1))s=d||0;else continue;const m=e.getBinPath(o,f);if(!m)continue;const P=k[s];P?P.path+=m:k[s]={path:m}}return k.forEach((o,f)=>{o&&this.appendPath(o.path).attr("fill",c.getColor(f))}),e}drawBinsProjected(){const t=this.prepareDraw({rounding:!1,nozoom:!0,extra:100,original:!0}),i=this.getHistGrFuncs(),e=this.getContourLevels(),n=this.getHistPalette(),c=_t(i.getProjectionFunc)?i.getProjectionFunc():(k,a)=>({x:k,y:a});return t.grz=k=>k,t.grz_min=e.at(0),t.grz_max=e.at(-1),se(this.getHisto(),t,e,(k,a)=>{let r="",d,g;for(let $=0;$<a.length;$+=3){const s=c(a[$],a[$+1]),h=Math.round(i.grx(s.x)),p=Math.round(i.gry(s.y));if($===0)r=`M${h},${p}`;else{if(h===d&&p===g)continue;$%9===0?r+=`m${h-d},${p-g}`:p===g?r+=`h${h-d}`:h===d?r+=`v${p-g}`:r+=`l${h-d},${p-g}`}d=h,g=p}this.appendPath(r).style("fill",n.calcColor(k,e.length))}),t}drawBinsContour(){const t=this.prepareDraw({rounding:!1,extra:100}),i=this.getContourLevels(),e=this.getHistPalette(),n=this.getOptions(),c=(a,r)=>{const d=a.x2-a.x1,g=a.y2-a.y1,$=r.x2-r.x1,s=r.y2-r.y1,h=d*s-$*g;if(h===0)return 0;const p=h>0,l=a.x1-r.x1,o=a.y1-r.y1,f=d*o-g*l;if(f<0===p)return null;const m=$*o-s*l;if(m<0===p||f>h===p||m>h===p)return null;const P=m/h;return{x:Math.round(a.x1+P*d),y:Math.round(a.y1+P*g)}},k=(a,r,d,g,$,s)=>{let h="",p,l,o,f,m=!1,P,_,T;for(let w=d;w<=g;++w){if(_=Math.round(a[w]),T=Math.round(r[w]),!h)h=`M${_},${T}`,o=_,f=T;else if(w===g&&d!==g&&_===o&&T===f){if(!m)return"";h+="z",$=!1,P=!0}else{const A=_-p,j=T-l;A?(m=!0,h+=j?`l${A},${j}`:`h${A}`):j&&(m=!0,h+=`v${j}`)}p=_,l=T}if(!$||P||!s)return $?h+"z":h;const u=[{x:0,y:0},{x:t.width,y:0},{x:t.width,y:t.height},{x:0,y:t.height}],C=(w,A)=>{const j={x1:a[w],y1:r[w],x2:2*a[w]-a[w+A],y2:2*r[w]-r[w+A]};for(let I=0;I<4;++I){const v=c(j,{x1:u[I].x,y1:u[I].y,x2:u[(I+1)%4].x,y2:u[(I+1)%4].y});if(v)return v.indx=I+.5,v}return null};let B,M;for(d--;d<g-1&&!B;)B=C(++d,1);if(!B)return"";for(g++;d<g-1&&!M;)M=C(--g,-1);if(!M)return"";let b=k(a,r,d,g),x=M.indx;const y=1,H=y*.5;for(b+=`L${M.x},${M.y}`;Math.abs(x-B.indx)>.1;)x=Math.round(x+H)%4,b+=`L${u[x].x},${u[x].y}`,x+=H;return b+`L${B.x},${B.y}z`};return n.Contour===14&&this.appendPath(`M0,0h${t.width}v${t.height}h${-t.width}z`).style("fill",e.calcColor(0,i.length)),ne(this.getHisto(),t,i,e,(a,r,d,g,$,s)=>{const h=e.getColor(a);let p=h,l;switch(n.Contour){case 1:break;case 11:p="none",l=this.createAttLine({color:h,std:!1});break;case 12:p="none",l=this.createAttLine({color:1,style:s%5+1,width:1,std:!1});break;case 13:p="none",l=this.lineatt;break}const o=k(r,d,g,$,p!=="none",!0);o&&this.appendPath(o).style("fill",p).call(l?l.func:()=>{})}),t.hide_only_zeros=!0,t}getGrNPoints(t){const i=t.fX,e=t.fY;let n=t.fNpoints;return n>2&&i[0]===i[n-1]&&e[0]===e[n-1]&&n--,n}createPolyGr(t,i,e){let n="",c=0,k=0;const a=i.fX,r=i.fY,d=()=>{c&&(n+="h"+c,c=0),k&&(n+="v"+k,k=0)},g=(o,f,m,P)=>{const _=Math.sqrt((o-m)**2+(f-P)**2);e.sumx+=(o+m)*_/2,e.sumy+=(f+P)*_/2,e.sum+=_},$=this.getGrNPoints(i);if($<2)return"";const s=Math.round(t.grx(a[0])),h=Math.round(t.gry(r[0]));let p=s,l=h;for(let o=1;o<$;++o){const f=Math.round(t.grx(a[o])),m=Math.round(t.gry(r[o])),P=f-p,_=m-l;e&&g(p,l,f,m),(P||_)&&(P===0?((k===0||_<0!=k<0)&&d(),k+=_):_===0?((c===0||P<0!=c<0)&&d(),c+=P):(d(),n+=`l${P},${_}`),p=f,l=m)}return e&&g(p,l,s,h),d(),n?`M${s},${h}`+n+"z":""}createPolyBin(t,i){const e=i.fPoly._typename===kt?i.fPoly.fGraphs.arr:[i.fPoly];let n="";for(let c=0;c<e.length;++c)n+=this.createPolyGr(t,e[c]);return n}async drawPolyBins(){const t=this.getHisto(),i=this.getOptions(),e=this.getHistGrFuncs(),n=i.Color||!i.Line&&!i.Fill&&!i.Text&&!i.Mark,c=i.Line||i.Text&&!n,k=i.Fill&&!n,a=i.Mark,r=e.getFrameHeight(),d=[],g=t.fBins.arr.length;let $,s,h="",p="",l,o,f,m=null,P=c,_=k,T=a;this.maxbin=this.gmaxbin,this.minbin=this.gminbin,this.minposbin=this.gminposbin;const u=n?this.getContour(!0):null,C=u?this.getHistPalette():null,B=w=>w.fXmin>e.scale_xmax||w.fXmax<e.scale_xmin||w.fYmin>e.scale_ymax||w.fYmax<e.scale_ymin;for(f=0;f<g;++f){if(l=t.fBins.arr[f],B(l))continue;const w=l.fPoly._typename===kt?l.fPoly.fGraphs.arr:[l.fPoly];for(let A=0;A<w.length;++A){const j=w[A];if(!m){m=j;continue}P&&(m.fLineColor!==j.fLineColor||m.fLineWidth!==j.fLineWidth||m.fLineStyle!==j.fLineStyle)&&(P=!1),_&&(m.fFillColor!==j.fFillColor||m.fFillStyle!==j.fFillStyle)&&(_=!1),T&&(m.fMarkerColor!==j.fMarkerColor||m.fMarkerStyle!==j.fMarkerStyle||m.fMarkerSize!==j.fMarkerSize)&&(T=!1)}if(!P&&!_&&!T)break}const M=P&&m?this.createAttLine(m):null,b=_&&m?this.createAttFill(m):null,x=T&&m?this.createAttMarker({attr:m,style:i.MarkStyle,std:!1}):null,y=!n&&(c?P:!0)&&(k?_:!0);for(f=0;f<g;++f){if(l=t.fBins.arr[f],B(l))continue;const w=l.fContent||i.Zero,A=l.fPoly._typename===kt?l.fPoly.fGraphs.arr:[l.fPoly];$=n&&w?u.getPaletteIndex(C,l.fContent):null;const j=i.Text&&w?{bin:l,sumx:0,sumy:0,sum:0}:null;for(let I=0;I<A.length;++I){const v=A[I];if(x){const N=this.getGrNPoints(v);for(let G=0;G<N;++G)p+=x.create(e.grx(v.fX[G]),e.gry(v.fY[G]))}s=this.createPolyGr(e,v,j),s&&(y?h+=s:($!==null||k||c)&&(o=this.appendPath(s),n&&$!==null?o.style("fill",C.getColor($)):k?o.call(this.createAttFill(v).func):o.style("fill","none"),c&&o.call(this.createAttLine(v).func)))}j?.sum&&d.push(j)}if(y&&(o=this.appendPath(h),k&&b?o.call(b.func):o.style("fill","none"),c&&M&&o.call(M.func)),x&&!x.empty()&&p)this.appendPath(p).call(x.func);else if(a)for(f=0;f<g;++f){if(l=t.fBins.arr[f],B(l))continue;const w=l.fPoly._typename===kt?l.fPoly.fGraphs.arr:[l.fPoly];for(let A=0;A<w.length;++A){const j=w[A],I=this.getGrNPoints(j),v=this.createAttMarker({attr:j,style:i.MarkStyle,std:!1});if(!I||v.empty())continue;let N="";for(let G=0;G<I;++G)N+=v.create(e.grx(j.fX[G]),e.gry(j.fY[G]));this.appendPath(N).call(v.func)}}let H=Promise.resolve();if(d.length){const w=this.getColor(t.fMarkerColor),A=-1*i.TextAngle,j=this.getG().append("svg:g").attr("class","th2poly_text"),I=t.fMarkerSize!==1&&A?Math.round(.02*r*t.fMarkerSize):12;H=this.startTextDrawingAsync(42,I,j,I).then(()=>{for(f=0;f<d.length;++f){const v=d[f];l=v.bin,v.sum>0?(v.midx=Math.round(v.sumx/v.sum),v.midy=Math.round(v.sumy/v.sum)):(v.midx=Math.round(e.grx((l.fXmin+l.fXmax)/2)),v.midy=Math.round(e.gry((l.fYmin+l.fYmax)/2)));let N;i.TextKind?(N=l.fPoly?.fName,(!N||N==="Graph")&&(N=l.fNumber.toString())):N=Math.round(l.fContent)===l.fContent?l.fContent.toString():ct(l.fContent,et.fPaintTextFormat),this.drawText({align:22,x:v.midx,y:v.midy,rotate:A,text:N,color:w,latex:0,draw_g:j})}return this.finishTextDrawing(j,!0)})}return H.then(()=>({poly:!0}))}async drawBinsText(t){t||(t=this.prepareDraw({rounding:!1}));const i=this.getHisto(),e=this.getOptions(),n=e.cutg,c=this.getColor(i.fMarkerColor),k=-1*e.TextAngle,a=this.getG().append("svg:g").attr("class","th2_text"),r=e.TextKind==="E",d=r&&!e.TextLine?1:0,g=i.fBarOffset*.001,$=i.fMarkerSize===1||!k?20:Math.round(.02*i.fMarkerSize*t.height);return this.startTextDrawingAsync(42,$,a,$).then(()=>{for(let s=t.i1;s<t.i2;++s){const h=t.grx[s+1]-t.grx[s];for(let p=t.j1;p<t.j2;++p){const l=i.getBinContent(s+1,p+1);if(l===0&&!e.ShowEmpty||n&&!n.IsInside(i.fXaxis.GetBinCoord(s+.5),i.fYaxis.GetBinCoord(p+.5)))continue;const o=t.gry[p]-t.gry[p+1];let f=l===Math.round(l)?l.toString():ct(l,et.fPaintTextFormat);if(r){const u=this.getBinErrors(i,i.getBin(s+1,p+1),l);if(u.poisson){const C=`-${ct(u.low,et.fPaintTextFormat)}  +${ct(u.up,et.fPaintTextFormat)}`;e.TextLine?f+=" "+C:f=`#splitmline{${f}}{${C}}`}else{const C=u.up===Math.round(u.up)?u.up.toString():ct(u.up,et.fPaintTextFormat);e.TextLine?f+="±"+C:f=`#splitmline{${f}}{#pm${C}}`}}let m,P,_,T;k?(m=Math.round(t.grx[s]+h*.5),P=Math.round(t.gry[p+1]+o*(.5+g)),_=T=0):(m=Math.round(t.grx[s]+h*.1),P=Math.round(t.gry[p+1]+o*(.1+g)),_=Math.round(h*.8),T=Math.round(o*.8)),this.drawText({align:22,x:m,y:P,width:_,height:T,rotate:k,text:f,color:c,latex:d,draw_g:a})}}return t.hide_only_zeros=!0,this.finishTextDrawing(a,!0)}).then(()=>t)}drawBinsArrow(){const t=this.getHisto(),i=this.getOptions(),e=i.cutg,n=this.prepareDraw({rounding:!1}),c=i.Color?this.getContour():null,k=i.Color?this.getHistPalette():null,a=(n.grx[n.i2]-n.grx[n.i1])/(n.i2-n.i1+1)/2,r=(n.gry[n.j2]-n.gry[n.j1])/(n.j2-n.j1+1)/2,d=(C,B)=>C?B?`l${C},${B}`:`h${C}`:B?`v${B}`:"",g=[];let $=1e-30,s,h,p,l,o="",f,m,P,_,T,u;for(let C=0;C<2;++C)for(let B=n.i1;B<n.i2;++B)for(let M=n.j1;M<n.j2;++M){if(e&&!e.IsInside(t.fXaxis.GetBinCoord(B+.5),t.fYaxis.GetBinCoord(M+.5)))continue;const b=t.getBinContent(B+1,M+1);if(B===n.i1?s=t.getBinContent(B+2,M+1)-b:B===n.i2-1?s=b-t.getBinContent(B,M+1):s=.5*(t.getBinContent(B+2,M+1)-t.getBinContent(B,M+1)),M===n.j1?h=t.getBinContent(B+1,M+2)-b:M===n.j2-1?h=b-t.getBinContent(B+1,M):h=.5*(t.getBinContent(B+1,M+2)-t.getBinContent(B+1,M)),C===0)$=Math.max($,Math.abs(s),Math.abs(h));else if(p=(n.grx[B]+n.grx[B+1])/2,l=(n.gry[M]+n.gry[M+1])/2,f=a*s/$,m=r*h/$,P=p-f,_=p+f,T=l-m,u=l+m,s=Math.round(_-P),h=Math.round(u-T),s||h){let x=`M${Math.round(P)},${Math.round(T)}${d(s,h)}`;if(Math.abs(s)>5||Math.abs(h)>5){const y=Math.sqrt(9/(s**2+h**2)),H=Math.round(y*(s+h)),w=Math.round(y*(s-h));(H||w)&&(x+=`m${-H},${w}${d(H,-w)}${d(-w,-H)}`)}if(k&&c){const y=c.getPaletteIndex(k,b);if(y!==null){const H=g[y];H?H.path+=x:g[y]={path:x}}}else o+=x}}return o&&this.appendPath(o).style("fill","none").call(this.lineatt.func),g.forEach((C,B)=>{if(C){const M=this.lineatt.color;this.lineatt.color=k.getColor(B),this.appendPath(C.path).attr("fill","none").call(this.lineatt.func),this.lineatt.color=M}}),n}drawBinsBox(){const t=this.getHisto(),i=this.getOptions(),e=this.prepareDraw({rounding:!1,zrange:!0}),n=Math.max(Math.abs(e.zmin),Math.abs(e.zmax)),c=Math.max(0,e.zmin),k=this.getPadPainter().getRootPad(!0),a=i.cutg;let r,d,g,$,s="",h="",p="",l="",o,f,m,P,_,T,u,C,B=!1,M=0;if((k?.fLogv??k?.fLogz)&&n>0){B=!0;const b=Math.log(n);c>0?M=Math.log(c):e.zminpos>=1&&e.zminpos<100?M=Math.log(.7):M=e.zminpos>0?Math.log(.7*e.zminpos):b-10,M>=b&&(M=b-10),C=1/(b-M)}else C=1/(n-c);for(r=e.i1;r<e.i2;++r)for(d=e.j1;d<e.j2;++d)if(g=t.getBinContent(r+1,d+1),$=Math.abs(g),!($===0||$<c)&&!(a&&!a.IsInside(t.fXaxis.GetBinCoord(r+.5),t.fYaxis.GetBinCoord(d+.5)))&&(o=B?$>0?Math.log($)-M:0:$-c,o=.5*(o<0?1:1-Math.sqrt(o*C)),o<0&&(o=0),T=e.grx[r+1]-e.grx[r],u=e.gry[d]-e.gry[d+1],f=o*T,m=o*u,P=Math.round(e.grx[r]+f),_=Math.round(e.gry[d+1]+m),T=Math.max(Math.round(T-2*f),1),u=Math.max(Math.round(u-2*m),1),s+=`M${P},${_}v${u}h${T}v${-u}z`,g<0&&i.BoxStyle===10&&(h+=`M${P},${_}l${T},${u}m0,${-u}l${-T},${u}`),i.BoxStyle===11&&T>5&&u>5)){const b=Qt(P,_,T,u,g<0?-1:1,Math.round(T*.1),Math.round(u*.1));p+=b[0],l+=b[1]}if(s){const b=this.appendPath(s).call(this.fillatt.func);i.BoxStyle!==11&&this.fillatt.empty()&&b.call(this.lineatt.func)}if(p&&this.fillatt.hasColor()&&this.appendPath(p).call(this.fillatt.func).style("fill",Ot(this.fillatt.color).brighter(.5).formatRgb()),l&&this.appendPath(l).call(this.fillatt.func).style("fill",this.fillatt.hasColor()?Ot(this.fillatt.color).darker(.5).formatRgb():"red"),h){const b=this.appendPath(h).style("fill","none");this.lineatt.empty()?b.style("stroke","black"):b.call(this.lineatt.func)}return e}drawBinsCandle(){let T=0;const u=this.getOptions(),C=S=>{let X=1;for(;S>=X;)X*=10;return X/=10,Math.floor(T/X)%10===Math.floor(S/X)},B=(S,X)=>{let L="",R="",O=0;const E=S[0],F=S[1];if(E>="A"&&E<="Z"&&(L=E),E>="1"&&E<="9"&&(R=E),F>="A"&&F<="Z"&&R&&(L=F),F>="1"&&F<="9"&&L&&(R=F),X)switch(R){case"1":O+=11311;break;case"2":O+=112111;break;case"3":O+=112311;break;case"4":O+=112321;break;case"5":O+=212111;break;case"6":O+=312311;break;default:O+=11311}else switch(R){case"1":O+=13001300;break;case"2":O+=13102300;break;default:O+=13001300}const V=S.indexOf("("),ut=S.lastIndexOf(")");V>=0&&ut>V+1&&(O=parseInt(S.slice(V+1,ut))),T=O,(L==="Y"||L==="H")&&!C(1e8)&&(T+=1e8)},M=(S,X,L)=>{let R=0,O=0,E=0;const F={max:0,first:-1,last:-1,entries:0};for(let V=0;V<X.length;++V)X[V]>0&&(F.max=Math.max(F.max,X[V]),F.first<0&&(F.first=V),F.last=V),R+=X[V],E+=X[V]*(S[V]+S[V+1])/2;if(R<=0)return null;F.entries=R,F.mean=E/R,F.quantiles=new Array(L.length),F.indx=new Array(L.length);for(let V=0,ut=0,gt=0;V<X.length;++V){const pt=gt;let wt=S[V];if(pt===L[O]&&X[V]===0&&pt<.99){for(;X[V]===0&&V<X.length;)V++;wt=(S[V]+wt)/2}for(ut+=X[V],gt=ut/R;L[O]>=pt&&L[O]<gt;){if(F.indx[O]=V,F.quantiles[O]=wt+(L[O]-pt)/(gt-pt)*(S[V+1]-wt),O++===L.length)return F;wt=S[V]}}for(;O<L.length;)F.indx[O]=X.length-1,F.quantiles[O++]=S.at(-1);return F};u.Candle?B(u.Candle,!0):u.Violin&&B(u.Violin,!1);const b=this.getHisto(),x=this.prepareDraw(),y=this.getCanvPainter(),H=this.getHistGrFuncs(),w=C(1e8);let A=et.fViolinScaled,j=et.fCandleScaled,I=0,v="",N="",G=null;if(u.Scaled!==null?A=j=u.Scaled:y?.online_canvas||(b.fTitle.indexOf("unscaled")>=0?A=j=!1:b.fTitle.indexOf("scaled")>=0&&(A=j=!0)),A&&(C(2e6)||C(1e6)||C(3e6)))for(let S=0;S<this.nbinsx;++S)for(let X=0;X<this.nbinsy;++X)I=Math.max(I,b.getBinContent(S+1,X+1));const Q=(...S)=>{S[1]==="array"&&(S=S[0]);const X=S.length;let L=2,R=S[0],O=S[1],E=w?`M${O},${R}`:`M${R},${O}`;for(;L<X;){switch(S[L]){case"Z":return E+"z";case"V":O!==S[L+1]&&(E+=(w?"h":"v")+(S[L+1]-O),O=S[L+1]);break;case"H":R!==S[L+1]&&(E+=(w?"v":"h")+(S[L+1]-R),R=S[L+1]);break;default:E+=w?`l${S[L+1]-O},${S[L]-R}`:`l${S[L]-R},${S[L+1]-O}`,R=S[L],O=S[L+1]}L+=2}return E},U=(S,X)=>{if(!v){const L=et.fCandleCrossLineWidth??1;this.createAttMarker({attr:b,style:C(3e5)?0:L===1?5:18*L+16}),this.markeratt.resetPos()}v+=w?this.markeratt.create(X,S):this.markeratt.create(S,X)},at=(S,X)=>{if(!G){const L=et.fCandleCircleLineWidth??1;G=this.createAttMarker({attr:b,style:L===1?24:18*L+17,std:!1}),G.resetPos()}N+=w?G.create(X,S):G.create(S,X)};b.fMarkerColor===1&&(b.fMarkerColor=b.fLineColor),x.candle=[];let q,W="",Z="",K="",tt="",J="",Y,D=0;const z=et.fCandleWhiskerRange,dt=et.fCandleBoxRange,Mt=[z>=1?1e-15:.5-z/2,dt>=1?1e-14:.5-dt/2,.5,dt>=1?1-1e-14:.5+dt/2,z>=1?1-1e-15:.5+z/2],lt=(S,X,L,R,O)=>{const E=M(q,Y,Mt);if(!E)return;const F={bin:S,swapXY:w,fBoxDown:E.quantiles[1],fMedian:E.quantiles[2],fBoxUp:E.quantiles[3]},V=F.fBoxUp-F.fBoxDown;let ut=E.quantiles[0],gt=E.quantiles[4];if(C(2e3)){let rt=F.fBoxDown-1.5*V,st=E.indx[1];for(;q[st]>rt&&st>0;)st--;for(;!Y[st];)st++;for(ut=q[st],rt=F.fBoxUp+1.5*V,st=E.indx[3];q[st]<rt&&st<Y.length;)st++;for(;!Y[st];)st--;gt=q[st+1]}const pt=E.mean,wt=1.57*V/Math.sqrt(E.entries);if(ut<=0&&(w&&H.logx||!w&&H.logy))return;const $t=L-X;let bt,Bt,it=(X+L)/2+b.fBarOffset/1e3*$t;b.fBarWidth>0&&b.fBarWidth!==1e3?bt=Bt=$t*b.fBarWidth/1e3:(bt=$t*.66,Bt=$t*.8),A&&I>0&&(Bt*=E.max/I),j&&D>0&&(bt*=E.entries/D),F.x1=Math.round(it-bt/2),F.x2=Math.round(it+bt/2),it=Math.round(it);const St=Math.round(it-bt/3),At=Math.round(it+bt/3),ht=w?H.grx:H.gry;F.yy1=Math.round(ht(gt)),F.y1=Math.round(ht(F.fBoxUp)),F.y0=Math.round(ht(F.fMedian)),F.y2=Math.round(ht(F.fBoxDown)),F.yy2=Math.round(ht(ut));const Ft=Math.round(ht(pt)),Xt=Math.round(ht(F.fMedian+wt)),vt=Math.round(ht(F.fMedian-wt));if(C(1e7)&&(J+=Q(it,Math.round(ht(q[R])),"V",Math.round(ht(q[O])))),C(10)?Z+=Q(F.x1,F.y0,"H",F.x2):C(20)?Z+=Q(St,F.y0,"H",At):C(30)&&at(it,F.y0),C(300)?at(it,Ft):C(100)&&(K+=Q(F.x1,Ft,"H",F.x2)),C(1)&&(C(20)?W+=Q(F.x1,F.y1,"V",Xt,St,F.y0,F.x1,vt,"V",F.y2,"H",F.x2,"V",vt,At,F.y0,F.x2,Xt,"V",F.y1,"Z"):W+=Q(F.x1,F.y1,"V",F.y2,"H",F.x2,"V",F.y1,"Z")),C(1e4)&&(Z+=Q(F.x1,F.yy1,"H",F.x2)+Q(F.x1,F.yy2,"H",F.x2)),C(1e3)&&!C(1e7)?K+=Q(it,F.y1,"V",F.yy1)+Q(it,F.y2,"V",F.yy2):(C(1e3)&&C(1e7)||C(2e3))&&(Z+=Q(it,F.y1,"V",F.yy1)+Q(it,F.y2,"V",F.yy2)),C(1e5)||C(2e5)||C(3e5)){const rt=new Yt(S*7521+Math.round(E.integral)),st=!C(1e5),yt=C(3e5);for(let ot=0;ot<Y.length;++ot){const ft=Y[ot],xt=(q[ot]+q[ot+1])/2;let Pt=it,jt;if(ft&&!(!st&&xt>=ut&&xt<=gt))for(let It=0;It<ft;It++)yt&&(Pt=it+Math.round((rt.random()-.5)*bt)),ft===1&&!yt?jt=Math.round(ht(xt)):jt=Math.round(ht(q[ot]+rt.random()*(q[ot+1]-q[ot]))),U(Pt,jt)}}if((C(2e6)||C(1e6)||C(3e6))&&E.max>0&&E.first>=0){const rt=[],st=(w?-.5:.5)*Bt/E.max;if(R=Math.max(R,E.first),O=Math.min(O-1,E.last),C(2e6)||C(3e6)){let yt=it,ot=Math.round(ht(q[R]));rt.push(yt,ot);for(let ft=R;ft<=O;ft++){const xt=Math.round(it+st*Y[ft]),Pt=Math.round(ht(q[ft+1]));xt!==yt&&(ft!==R&&rt.push("V",ot),rt.push("H",xt)),yt=xt,ot=Pt}rt.push("V",ot)}if(C(1e6)||C(3e6)){let yt=it,ot=Math.round(ht(q[O+1]));rt.length||rt.push(yt,ot);for(let ft=O;ft>=R;ft--){const xt=Math.round(it-st*Y[ft]),Pt=Math.round(ht(q[ft]));xt!==yt&&(ft!==O&&rt.push("V",ot),rt.push("H",xt)),yt=xt,ot=Pt}rt.push("V",ot)}rt.push("H",it),tt+=Q(rt,"array"),this.fillatt.empty()||(tt+="Z")}x.candle.push(F)};if(w){q=new Array(this.nbinsx+1),Y=new Array(this.nbinsx);for(let S=0;S<this.nbinsx+1;++S)q[S]=b.fXaxis.GetBinLowEdge(S+1);if(j)for(let S=0;S<this.nbinsy;++S){let X=0;for(let L=0;L<this.nbinsx;++L)X+=b.getBinContent(L+1,S+1);D=Math.max(D,X)}for(let S=x.j1;S<x.j2;++S){for(let X=0;X<this.nbinsx;++X)Y[X]=b.getBinContent(X+1,S+1);lt(S,x.gry[S+1],x.gry[S],x.i1,x.i2)}}else{q=new Array(this.nbinsy+1),Y=new Array(this.nbinsy);for(let S=0;S<this.nbinsy+1;++S)q[S]=b.fYaxis.GetBinLowEdge(S+1);if(j)for(let S=0;S<this.nbinsx;++S){let X=0;for(let L=0;L<this.nbinsy;++L)X+=b.getBinContent(S+1,L+1);D=Math.max(D,X)}for(let S=x.i1;S<x.i2;++S){for(let X=0;X<this.nbinsy;++X)Y[X]=b.getBinContent(S+1,X+1);lt(S,x.grx[S],x.grx[S+1],x.j1,x.j2)}}J&&b.fFillColor>0&&this.appendPath(J).style("stroke",this.getColor(b.fFillColor));const nt=C(1e7)&&b.fFillStyle?this.fillatt.color:this.lineatt.color;if(tt&&(!this.fillatt.empty()||nt!=="none")&&this.appendPath(tt).style("stroke",nt!=="none"?nt:null).style("pointer-events",this.isBatchMode()?null:"visibleFill").call(this.fillatt.func),W&&this.appendPath(W).call(this.lineatt.func).call(this.fillatt.func),Z&&this.appendPath(Z).call(this.lineatt.func).style("fill","none"),K){const S=this.createAttLine({attr:b,style:2,std:!1,color:te});this.appendPath(K).call(S.func).style("fill","none")}return N&&this.appendPath(N).call(G.func),v&&this.appendPath(v).call(this.markeratt.func),x}drawBinsScatter(){const t=this.getHisto(),i=this.getOptions(),e=this.prepareDraw({rounding:!0,pixel_density:!0}),n=i.cutg,c=[],k=[],a=[],r=[],d=[],g=i.ScatCoef*(this.gmaxbin>2e3?2e3/this.gmaxbin:1),$=new Yt(e.sumz);let s,h,p,l,o,f,m,P,_=1;if(e.ScatterPlot=!0,g*e.sumz<1e5){this.createAttMarker({attr:t}),this.markeratt.resetPos();let b="";for(l=e.i1;l<e.i2;++l)for(m=e.grx[l+1]-e.grx[l],o=e.j1;o<e.j2;++o){P=e.gry[o]-e.gry[o+1],f=t.getBinContent(l+1,o+1);const x=Math.round(g*f);if(!(x<=0)&&!(n&&!n.IsInside(t.fXaxis.GetBinCoord(l+.5),t.fYaxis.GetBinCoord(o+.5))))for(let y=0;y<x;++y)b+=this.markeratt.create(Math.round(e.grx[l]+m*$.random()),Math.round(e.gry[o+1]+P*$.random()))}return this.appendPath(b).call(this.markeratt.func),e}this.maxbin>.7&&(_=.7/this.maxbin);const T=Math.round(e.max-e.min),u=this.createContour(T>50?50:T,this.minposbin,this.maxbin,this.minposbin);for(l=e.i1;l<e.i2;++l)for(o=e.j1;o<e.j2;++o)f=t.getBinContent(l+1,o+1),!(f<=0||f<this.minbin)&&(m=e.grx[l+1]-e.grx[l],P=e.gry[o]-e.gry[o+1],!(m*P<=0)&&(s=u.getContourIndex(f/m/P),!(s<0)&&(n&&!n.IsInside(t.fXaxis.GetBinCoord(l+.5),t.fYaxis.GetBinCoord(o+.5))||(h=`M${e.grx[l]},${e.gry[o+1]}`,c[s]===void 0?(c[s]=h,r[s]=m,d[s]=P):(p=`m${e.grx[l]-k[s]},${e.gry[o+1]-a[s]}`,c[s]+=p.length<h.length?p:h,r[s]=Math.max(r[s],m),d[s]=Math.max(d[s],P)),k[s]=e.grx[l],a[s]=e.gry[o+1],c[s]+=`v${P}h${m}v${-P}z`))));const C=this.getPadPainter(),B=C.selectChild(".main_layer");let M=B.selectChild("defs");for(M.empty()&&c.length&&(M=B.insert("svg:defs",":first-child")),this.createAttMarker({attr:t}),s=0;s<c.length;++s)if(c[s]!==void 0&&s<u.arr.length){const b=(C.getPadName()||"canv")+`_scatter_${s}`;let x=M.selectChild(`#${b}`);x.empty()?x=M.append("svg:pattern").attr("id",b).attr("patternUnits","userSpaceOnUse"):x.selectAll("*").remove();let y=Math.round(_*u.arr[s]*r[s]*d[s]);y=Math.max(1,y);const H=new Float32Array(y),w=new Float32Array(y);if(y===1)H[0]=w[0]=.5;else for(let j=0;j<y;++j)H[j]=$.random(),w[j]=$.random();this.markeratt.resetPos();let A="";for(let j=0;j<y;++j)A+=this.markeratt.create(H[j]*r[s],w[j]*d[s]);x.attr("width",r[s]).attr("height",d[s]).append("svg:path").attr("d",A).call(this.markeratt.func),this.appendPath(c[s]).attr("scatter-index",s).style("fill",`url(#${b})`)}return e}draw2DBins(){const t=this.getOptions();if(this.#r&&this.isMainPainter()?(this.getPadPainter().getFrameSvg().style("display",null),this.#r=void 0):t.Same&&!this.isUseFrame()&&this.getPadPainter().getFrameSvg().style("display","none"),!this.draw_content)return t.Zscale&&t.ohmin&&t.ohmax&&(this.getContour(!0),this.getHistPalette()),this.removeG();this.createHistDrawAttributes(),this.createG(this.isUseFrame());let i,e;if(this.isTH2Poly()?e=this.drawPolyBins():(t.Scat&&(i=this.drawBinsScatter()),t.System===ie?i=this.drawBinsPolar():t.Arrow?i=this.drawBinsArrow():t.Color?i=this.drawBinsColor():t.Box?i=this.drawBinsBox():t.Proj?i=this.drawBinsProjected():t.Contour?i=this.drawBinsContour():(t.Candle||t.Violin)&&(i=this.drawBinsCandle()),t.Text&&(e=this.drawBinsText(i)),!i&&!e&&(i=this.drawBinsColor())),i)this.tt_handle=i;else if(e)return e.then(n=>{this.tt_handle=n})}async drawBinsCircular(){this.#r=!0;const t=this.getPadPainter(),i=t.getFrameRect(),e=this.getHisto(),n=this.getOptions().Circular,c=n>10?this.getHistPalette():null,k=20,a=16,r=e.fXaxis,d=this.createG(),g=s=>{if(r.fLabels)for(let h=0;h<r.fLabels.arr.length;++h){const p=r.fLabels.arr[h];if(p.fUniqueID===s+1)return p.fString}return s.toString()};t.getFrameSvg().style("display","none"),this.assignChordCircInteractive(Math.round(i.x+i.width/2),Math.round(i.y+i.height/2));const $=Math.min(this.nbinsx,this.nbinsy);return this.startTextDrawingAsync(42,k,d).then(()=>{const s=[];for(let o=0;o<$;o++){const f=(.5-o/$)*Math.PI*2,m=Math.round((.9*i.width/2-2*a)*Math.cos(f)),P=Math.round((.9*i.height/2-2*a)*Math.sin(f)),_=Math.round(.9*i.width/2*Math.cos(f)),T=Math.round(.9*i.height/2*Math.sin(f)),u=c?.calcColor(o,$)??"black";let C=Math.round(f/Math.PI*180),B=12;s.push({x:m,y:P,a:f,color:u}),(C<-90||C>90)&&(C+=180,B=32);const M=Math.round(k/2),b=2*M;d.append("path").attr("d",`M${m-M},${P} a${M},${M},0,1,0,${b},0a${M},${M},0,1,0,${-b},0z`).style("stroke",u).style("fill","none"),this.drawText({align:B,rotate:C,x:_,y:T,text:g(o)})}const h=a/2;let p=0,l=0;if(n>11)for(let o=0;o<$-1;++o)for(let f=o+1;f<$;++f){const m=e.getBinContent(o+1,f+1);m>0&&(p=Math.max(p,m),(!l||m<l)&&(l=m))}for(let o=0;o<$-1;++o){const f=s[o];let m="";for(let P=o+1;P<$;++P){const _=e.getBinContent(o+1,P+1);if(_<=0)continue;const T=s[P],u=(f.a+T.a)/2,C=.5*(1-Math.abs(f.a-T.a)/Math.PI),B=Math.round(C*i.width/2*Math.cos(u)),M=Math.round(C*i.height/2*Math.sin(u));if(m+=`M${f.x},${f.y}Q${B},${M},${T.x},${T.y}`,n>11&&p>l){const b=Math.round((_-l)/(p-l)*(h-1)+1);d.append("path").attr("d",m).style("stroke",f.color).style("stroke-width",b).style("fill","none"),m=""}}m&&d.append("path").attr("d",m).style("stroke",f.color).style("fill","none")}return this.finishTextDrawing()}).then(()=>(this.isBatchMode()||d.insert("path",":first-child").attr("d",`M${-i.width/2},${-i.height/2}h${i.width}v${i.height}h${-i.width}z`).style("opacity",0).style("fill","none").style("pointer-events","visibleFill"),this))}assignChordCircInteractive(t,i){this.#e||(this.#e={x:0,y:0,zoom:1}),Tt(this.getG(),t+this.#e.x,i+this.#e.y,this.#e.zoom),!this.isBatchMode()&&(Dt.Zooming&&Dt.ZoomWheel&&this.getG().on("wheel",e=>{const n=Wt(e,this.getG().node()),c=e.wheelDelta?-e.wheelDelta:e.deltaY||e.detail,k=this.#e.zoom;this.#e.zoom*=c>0?.8:1.2,this.#e.x+=n[0]*(k-this.#e.zoom),this.#e.y+=n[1]*(k-this.#e.zoom),Tt(this.getG(),t+this.#e.x,i+this.#e.y,this.#e.zoom)}).on("dblclick",()=>{this.#e.x=this.#e.y=0,this.#e.zoom=1,Tt(this.getG(),t,i)}),Zt(this))}async drawBinsChord(){this.getPadPainter().getFrameSvg().style("display","none"),this.#r=!0;const t=[],i=Math.min(this.nbinsx,this.nbinsy),e=this.getHisto();let n=0,c=!0;for(let x=0;x<i;++x){let y=0;for(let H=0;H<i;++H){const w=e.getBinContent(x+1,H+1);w>0&&(y+=w,c&&Math.round(w)!==w&&(c=!1))}y>0&&t.push(x),n+=y}if(t.length<2)return!0;let k=0,a=1;const r=this.getPadPainter().getFrameRect(),d=Math.round(r.x+r.width/2),g=Math.round(r.y+r.height/2),$=this.getHistPalette(),s=Math.max(10,Math.min(r.width,r.height)*.5-60),h=Math.max(2,s-10),p=[],l=[],o=x=>x.toString(),f=x=>k>3?x.toExponential(0):x.toFixed(k),m=(x,y)=>y<x?-1:y>x?1:y>=x?0:Number.NaN;if(!c&&n<10){const x=Math.round(Math.log10(n)-2.3);k=-x,a=Math.pow(10,x)}else if(n>200){const x=Math.round(Math.log10(n)-2.3);a=Math.pow(10,x)}a*250<n?a*=5:a*100<n&&(a*=2);for(let x=0;x<t.length;++x){p[x]=[];for(let w=0;w<t.length;++w)p[x].push(e.getBinContent(t[x]+1,t[w]+1));const y=e.fXaxis;let H="indx_"+t[x].toString();if(y.fLabels)for(let w=0;w<y.fLabels.arr.length;++w){const A=y.fLabels.arr[w];if(A.fUniqueID===t[x]+1){H=A.fString;break}}l.push(H)}const P=this.createG();this.assignChordCircInteractive(d,g);const _=Ut().padAngle(10/h).sortSubgroups(m).sortChords(m),T=_(p),u=P.append("g").attr("font-size",10).attr("font-family","sans-serif").selectAll("g").data(T.groups).join("g"),C=qt().innerRadius(h).outerRadius(s),B=Kt().radius(h-1).padAngle(1/h);function M({startAngle:x,endAngle:y,value:H}){const w=(y-x)/H,A=[];for(let j=0;j<=H;j+=a)A.push({value:j,angle:j*w+x});return A}u.append("path").attr("fill",x=>$.calcColor(x.index,t.length)).attr("d",C),u.append("title").text(x=>`${l[x.index]} ${o(x.value)}`);const b=u.append("g").selectAll("g").data(M).join("g").attr("transform",x=>`rotate(${Math.round(x.angle*180/Math.PI-90)}) translate(${s})`);return b.append("line").attr("stroke","currentColor").attr("x2",6),b.append("text").attr("x",8).attr("dy","0.35em").attr("transform",x=>x.angle>Math.PI?"rotate(180) translate(-16)":null).attr("text-anchor",x=>x.angle>Math.PI?"end":null).text(x=>f(x.value)),u.select("text").attr("font-weight","bold").text(function(x){return this.getAttribute("text-anchor")==="end"?`↑ ${l[x.index]}`:`${l[x.index]} ↓`}),P.append("g").attr("fill-opacity",.8).selectAll("path").data(T).join("path").style("mix-blend-mode","multiply").attr("fill",x=>$.calcColor(x.source.index,t.length)).attr("d",B).append("title").text(x=>`${o(x.source.value)} ${l[x.target.index]} → ${l[x.source.index]}${x.source.index===x.target.index?"":`
${o(x.target.value)} ${l[x.source.index]} → ${l[x.target.index]}`}`),this.isBatchMode()||P.insert("ellipse",":first-child").attr("cx",0).attr("cy",0).attr("rx",s*1.2).attr("ry",s*1.2).style("opacity",0).style("fill","none").style("pointer-events","visibleFill"),!0}getBinTooltips(t,i){const e=this.getHisto(),n=this.matchObjectType(Ct)&&_t(e.getBinEntries),c=e.getBinContent(t+1,i+1);let k=c;e.$baseh&&(k-=e.$baseh.getBinContent(t+1,i+1));const a=[this.getObjectHint(),"x = "+this.getAxisBinTip("x",e.fXaxis,t),"y = "+this.getAxisBinTip("y",e.fYaxis,i),`bin = ${e.getBin(t+1,i+1)}  x: ${t+1}  y: ${i+1}`,"content = "+(k===Math.round(k)?k:ct(k,et.fStatFormat))];if(this.getOptions().TextKind==="E"||n||e.fSumw2?.length){const r=this.getBinErrors(e,e.getBin(t+1,i+1),c);r.poisson?a.push("error low = "+ct(r.low,et.fPaintTextFormat),"error up = "+ct(r.up,et.fPaintTextFormat)):a.push("error = "+ct(r.up,et.fPaintTextFormat))}if(n){const r=e.getBinEntries(t+1,i+1);a.push("entries = "+(r===Math.round(r)?r:ct(r,et.fStatFormat)))}return a}getCandleTooltips(t){const i=this.getHistGrFuncs(),e=this.getHisto();return[this.getObjectHint(),t.swapXY?"y = "+i.axisAsText("y",e.fYaxis.GetBinLowEdge(t.bin+1)):"x = "+i.axisAsText("x",e.fXaxis.GetBinLowEdge(t.bin+1)),"m-25%  = "+ct(t.fBoxDown,et.fStatFormat),"median = "+ct(t.fMedian,et.fStatFormat),"m+25%  = "+ct(t.fBoxUp,et.fStatFormat)]}getPolyBinTooltips(t,i,e){const n=this.getHisto(),c=n.fBins.arr[t],k=this.getHistGrFuncs(),a=[];let r=c.fPoly.fName,d=0;if(r==="Graph"&&(r=""),r||(r=c.fNumber),i===void 0&&e===void 0){i=e=0;let g=c.fPoly,$=1;g._typename===kt&&($=c.fPoly.fGraphs.arr.length,g=null);for(let s=0;s<$;++s){(!g||s>0)&&(g=c.fPoly.fGraphs.arr[s]);for(let h=0;h<g.fNpoints;++h)++d,i+=g.fX[h],e+=g.fY[h]}d>1&&(i/=d,e/=d)}return a.push(this.getObjectHint(),"x = "+k.axisAsText("x",i),"y = "+k.axisAsText("y",e)),d>0&&a.push("npnts = "+d),a.push(`bin = ${r}`),c.fContent===Math.round(c.fContent)?a.push("content = "+c.fContent):a.push("content = "+ct(c.fContent,et.fStatFormat)),a}processTooltipEvent(t){const i=this.getHisto(),e=this.getOptions(),n=this.tt_handle;let c=this.getG()?.selectChild(".tooltip_bin");if(!t||!this.draw_content||!this.getG()||!n||e.Proj)return c?.remove(),null;if(n.poly){const T=this.getHistGrFuncs(),u=T.revertAxis("x",t.x),C=T.revertAxis("y",t.y);let B=-1,M;if(u!==void 0&&C!==void 0){const x=i.fBins.arr.length;for(let y=0;y<x&&B<0;++y){if(M=i.fBins.arr[y],u<M.fXmin||u>M.fXmax||C<M.fYmin||C>M.fYmax||!M.fContent&&!e.Zero)continue;let H=M.fPoly,w=1;H._typename===kt&&(w=M.fPoly.fGraphs.arr.length,H=null);for(let A=0;A<w;++A)if((!H||A>0)&&(H=M.fPoly.fGraphs.arr[A]),H.IsInside(u,C)){B=y;break}}}if(B<0)return c.remove(),null;const b={name:i.fName,title:i.fTitle,x:t.x,y:t.y,color1:this.lineatt?.color??"green",color2:this.fillatt?.getFillColorAlt("blue")??"blue",exact:!0,menu:!0,lines:this.getPolyBinTooltips(B,u,C)};return t.disabled?(c.remove(),b.changed=!0):(c.empty()&&(c=this.appendPath().attr("class","tooltip_bin").style("pointer-events","none").call(Ht)),b.changed=c.property("current_bin")!==B,b.changed&&c.attr("d",this.createPolyBin(T,M)).style("opacity","0.7").property("current_bin",B)),b.changed&&(b.user_info={obj:i,name:i.fName,bin:B,cont:M.fContent,grx:t.x,gry:t.y}),b}else if(n.candle){let T,u,C;for(T=0;T<n.candle.length&&(u=n.candle[T],C=u.swapXY?u.x1<=t.y&&t.y<=u.x2&&u.yy1>=t.x&&t.x>=u.yy2:u.x1<=t.x&&t.x<=u.x2&&u.yy1<=t.y&&t.y<=u.yy2,!C);++T);if(!C)return c.remove(),null;const B={name:i.fName,title:i.fTitle,x:t.x,y:t.y,color1:this.lineatt?.color??"green",color2:this.fillatt?.getFillColorAlt("blue")??"blue",lines:this.getCandleTooltips(u),exact:!0,menu:!0};return t.disabled?(c.remove(),B.changed=!0):(c.empty()&&(c=this.appendPath().attr("class","tooltip_bin").style("pointer-events","none").call(Ht).style("opacity","0.7")),B.changed=c.property("current_bin")!==T,B.changed&&c.attr("d",u.swapXY?`M${u.yy1},${u.x1}H${u.yy2}V${u.x2}H${u.yy1}Z`:`M${u.x1},${u.yy1}H${u.x2}V${u.yy2}H${u.x1}Z`).property("current_bin",T)),B.changed&&(B.user_info={obj:i,name:i.fName,bin:T+1,cont:u.fMedian,binx:T+1,biny:1,grx:t.x,gry:t.y}),B}const k=this.getFramePainter();let a,r,d=0,g=null,$=!1,s,h,p,l,o,f,m,P;if(_t(n.findBin)){const T=n.findBin(t.x,t.y);a=T?.i??n.i2,r=T?.j??n.j2,$=!0}else{if(k.reverse_x())for(a=n.i1;a<n.i2&&(t.x>n.grx[a]||t.x<n.grx[a+1]);++a);else for(a=n.i1;a<n.i2&&(t.x<n.grx[a]||t.x>n.grx[a+1]);++a);if(k.reverse_y())for(r=n.j1;r<n.j2&&(t.y>n.gry[r+1]||t.y<n.gry[r]);++r);else for(r=n.j1;r<n.j2&&(t.y<n.gry[r+1]||t.y>n.gry[r]);++r);}if(a<n.i2&&r<n.j2){s=a,h=a+1,p=r,l=r+1,o=n.grx[s],f=n.grx[h],m=n.gry[l],P=n.gry[p];let T=!0;if(e.Color&&!$){const u=f-o,C=P-m;f=Math.round(o+u*n.xbar2),o=Math.round(o+u*n.xbar1),P=Math.round(m+C*n.ybar2),m=Math.round(m+C*n.ybar1),k.reverse_x()?(t.x>o||t.x<=f)&&(T=!1):(t.x<o||t.x>=f)&&(T=!1),k.reverse_y()?(t.y>m||t.y<=P)&&(T=!1):(t.y<m||t.y>=P)&&(T=!1)}d=i.getBinContent(a+1,r+1),this.#t?g=0:T?n.hide_only_zeros?g=d===0&&!e.ShowEmpty?null:0:(g=this.getContour().getPaletteIndex(this.getHistPalette(),d),g===null&&d===0&&(e.ShowEmpty||i._typename===Ct&&i.getBinEntries(a+1,r+1))&&(g=0)):g=null}if(g===null)return c.remove(),null;const _={name:i.fName,title:i.fTitle,x:t.x,y:t.y,color1:this.lineatt?.color??"green",color2:this.fillatt?.getFillColorAlt("blue")??"blue",lines:this.getBinTooltips(a,r),exact:!0,menu:!0};if(e.Color&&(_.color2=this.getHistPalette().getColor(g)),t.disabled&&!this.#t)c.remove(),_.changed=!0;else{c.empty()&&(c=this.appendPath().attr("class","tooltip_bin").style("pointer-events","none").call(Ht));let T=a*1e4+r,u;if(this.#t){const C=this.#i||1,B=(C-1)/2;this.#t.indexOf("X")>=0&&C>1&&(l+B>=n.j2?(l=Math.min(Math.round(l+B),n.j2),p=Math.max(l-C,n.j1)):(p=Math.max(Math.round(p-B),n.j1),l=Math.min(p+C,n.j2)));const M=this.#n||1,b=(M-1)/2;this.#t.indexOf("Y")>=0&&M>1&&(h+b>=n.i2?(h=Math.min(Math.round(h+b),n.i2),s=Math.max(h-M,n.i1)):(s=Math.max(Math.round(s-b),n.i1),h=Math.min(s+M,n.i2)))}$?u=n.getBinPath(a,r):this.#t==="X"?(o=0,f=k.getFrameWidth(),m=n.gry[l],P=n.gry[p],T=p*777+l*333):this.#t==="Y"?(m=0,P=k.getFrameHeight(),o=n.grx[s],f=n.grx[h],T=s*777+h*333):this.#t==="XY"&&(m=n.gry[l],P=n.gry[p],o=n.grx[s],f=n.grx[h],T=s*789+h*653+p*12345+l*654321,u=`M${o},0H${f}V${m}H${k.getFrameWidth()}V${P}H${f}V${k.getFrameHeight()}H${o}V${P}H0V${m}H${o}Z`),_.changed=c.property("current_bin")!==T,_.changed&&c.attr("d",u||`M${o},${m}H${f}V${P}H${o}Z`).style("opacity","0.7").property("current_bin",T),this.#t&&_.changed&&this.redrawProjection(s,h,p,l)}return _.changed&&(_.user_info={obj:i,name:i.fName,bin:i.getBin(a+1,r+1),cont:d,binx:a+1,biny:r+1,grx:t.x,gry:t.y}),_}canZoomInside(t,i,e){const n=this.getOptions();if(n.Proj)return!0;if(t==="z"){if(this.mode3d)return!0;if(n.IgnorePalette)return!1;const k=this.getFramePainter(),a=Math.max(2*et.fNumberContours,100),r=this.getPadPainter().getRootPad(!0),d=r?.fLogv??r?.fLogz;return!k||k.zmin===k.zmax?!0:d&&k.zmin>0&&i>0?a*Math.log(e/i)>Math.log(k.zmax/k.zmin):k.zmax-k.zmin<(e-i)*a}let c=this.getHisto();return c&&(c=t==="y"?c.fYaxis:c.fXaxis),!c||c.FindBin(e,.5)-c.FindBin(i,0)>1}completePalette(t){if(!t)return!0;const i=this.getOptions();return t.$main_painter=this,i.Zvert=t.isPaletteVertical(),t.drawPave(i.Cjust?"cjust":"")}async draw2D(){this.clear3DScene();const t=this.getOptions(),i=t.Zscale&&t.canHavePalette()&&this.isUseFrame();return this.drawColorPalette(i,!0,this.#s).then(async e=>{this.#s=void 0;let n;return t.Circular&&this.isMainPainter()?n=this.drawBinsCircular():t.Chord&&this.isMainPainter()?n=this.drawBinsChord():n=this.drawAxes().then(()=>this.draw2DBins()),n.then(()=>this.completePalette(e))}).then(()=>this.updateFunctions()).then(()=>this.updateHistTitle()).then(()=>(this.updateStatWebCanvas(),this.addInteractivity()))}async draw3D(t){return console.log("3D drawing is disabled, load ./hist/TH2Painter.mjs"),this.draw2D(t)}async callDrawFunc(t){const i=this.getMainPainter(),e=this.getFramePainter(),n=this.getOptions();return i!==this&&e&&e.mode3d!==n.Mode3D&&this.copyOptionsFrom(i),n.Mode3D?this.draw3D(t).catch(c=>{const k=this.getCanvPainter();return _t(k?.showConsoleError)?k.showConsoleError(c):console.error("Fail to draw histogram in 3D - back to 2D"),n.Mode3D=!1,this.draw2D(t)}):this.draw2D(t)}async redraw(t){return this.callDrawFunc(t)}static async draw(t,i,e){return Nt._drawHist(new Et(t,i),e)}};export{le as T,re as a,ne as b,se as c};
