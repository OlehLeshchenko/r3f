import{O as L,B as j,l as y,p as G,t as k,j as X,a1 as F,a2 as S,r as R,q as Y,D as _,e as $}from"./index-DAa9yKAB.js";import{F as O}from"./THistPainter-DJAmNO-k.js";import{T as b,P as A}from"./TH1Painter-C7yoCsum.js";import{TGraphPainter as B}from"./TGraphPainter-DECA4bpc.js";import{TH2Painter as I}from"./TH2Painter-yQJYXbd3.js";import{T as C}from"./TGraphPainter-C8qCwVCh.js";import"./TPavePainter-DMWA3hUD.js";import"./func-CztLwFD8.js";import"./hist3d-BC5Tno_J.js";import"./latex3d-BISPawP1.js";import"./TH2Painter-Ba0oelVz.js";import"./TH1Painter-BmkwKNTG.js";const E=j(17);let W=class H extends L{#i;#t;#s;#r;#e;#n;#a;constructor(e,i){super(e,i),this.#i=null,this.#t=[]}cleanup(){this.#t=[],this.#n=void 0,this.#a=void 0,this.#e=void 0,this.#r=void 0,super.cleanup()}is3d(){return this.#n}updateObject(e){if(!this.matchObjectType(e))return!1;const i=this.getObject(),a=e.fGraphs,n=this.getPadPainter();i.fTitle=e.fTitle;let h=!1;if(this.#i){const m=this.scanGraphsRange(a,e.fHistogram,n?.getRootPad(!0),!0);this.#i.updateObject(m)&&(h=!0)}const t=Math.min(a.arr.length,this.#t.length);for(let m=0;m<t;++m)this.#t[m].updateObject(a.arr[m],(a.opt[m]||this.#r)+this.#e)&&(h=!0);return this.#s=new O(this,n,e.fFunctions),h}async redraw(e){const i=this.#i?.redraw(e)??Promise.resolve(!0),a=async n=>n>=this.#t.length?this:this.#t[n].redraw(e).then(()=>a(n+1));return i.then(()=>a(0)).then(()=>{const n=this.#s?.drawNext(0)??this;return this.#s=void 0,n})}scanGraphsRange(e,i,a,n){const h=this.getObject(),t={xmin:0,xmax:0,ymin:0,ymax:0,first:!0},m=(s,u)=>Math.abs(u-s)<1e-6;let r,f,p=!1,l=!1,c,w=!1;a&&(p=a.fLogx,l=a.fLogv??a.fLogy),this.is3d()&&i&&!i.fXaxis.fLabels&&(i=null),i?(w=m(i.fMinimum,-.05)&&m(i.fMaximum,1.05)&&m(i.fXaxis.fXmin,-.05)&&m(i.fXaxis.fXmax,1.05),c=i):c=e.arr[0]?.fHistogram,e.arr.forEach(s=>{if(s.fNpoints!==0){s.TestBit(E)&&(n=!0),t.first&&(t.xmin=t.xmax=s.fX[0],t.ymin=t.ymax=s.fY[0],t.first=!1);for(let u=0;u<s.fNpoints;++u)t.xmin=Math.min(t.xmin,s.fX[u]),t.xmax=Math.max(t.xmax,s.fX[u]),t.ymin=Math.min(t.ymin,s.fY[u]),t.ymax=Math.max(t.ymax,s.fY[u])}}),t.xmin===t.xmax&&(t.xmax+=1),t.ymin===t.ymax&&(t.ymax+=1);const P=.05*(t.xmax-t.xmin),T=.05*(t.ymax-t.ymin);let d=t.xmin-P,o=t.xmax+P;l?(t.ymin<=0&&(t.ymin=.001*t.ymax),f=t.ymin/(1+.5*Math.log10(t.ymax/t.ymin)),r=t.ymax*(1+.2*Math.log10(t.ymax/t.ymin))):(f=t.ymin-T,r=t.ymax+T),f<0&&t.ymin>=0&&(f=0),r>0&&t.ymax<=0&&(r=0);const v=f,D=r;if(d<0&&t.xmin>=0&&(d=p?.9*t.xmin:0),o>0&&t.xmax<=0&&(o=p?1.1*t.xmax:0),h.fMinimum!==y&&(t.ymin=f=h.fMinimum),h.fMaximum!==y&&(t.ymax=r=h.fMaximum),f<0&&t.ymin>=0&&l&&(f=.9*t.ymin),r>0&&t.ymax<=0&&l&&(r=1.1*t.ymax),f<=0&&l&&(f=.001*r),!l&&f>0&&f<.05*r&&(f=0),d<=0&&p&&(d=o>1e3?1:.001*o),!i||n||w){let s,u;if(this.is3d()){i=G(k,e.arr.length,10),s=i.fXaxis,s.fXmin=0,s.fXmax=e.arr.length,s.fLabels=X(F);for(let x=0;x<e.arr.length;x++){const g=X(S);g.fString=e.arr[x].fTitle||`gr${x}`,g.fUniqueID=e.arr.length-x,s.fLabels.Add(g,"")}s=i.fYaxis,u=i.fZaxis}else i=G(c?._typename??R,c?.fXaxis.fNbins??10),s=i.fXaxis,u=i.fYaxis;if(c&&(Object.assign(s,c.fXaxis),u.fTitle=c.fYaxis.fTitle),i.fTitle=h.fTitle,i.fTitle.indexOf(";")>=0){const x=i.fTitle.split(";");i.fTitle=x[0],x[1]&&(s.fTitle=x[1]),x[2]&&(u.fTitle=x[2])}s.fLabels||(s.fXmin=d,s.fXmax=o)}const M=this.is3d()?i.fZaxis:i.fYaxis;return M.fXmin=Math.min(f,v),M.fXmax=Math.max(r,D),i.fMinimum===y&&(i.fMinimum=f),i.fMaximum===y&&(i.fMaximum=r),i.fBits|=Y,i}async drawAxisHist(e,i){return b.draw(this.getDrawDom(),e,i)}async drawGraph(e,i,a){return B.draw(e,i,a)}async drawNextGraph(e,i){const a=this.getObject().fGraphs;if(e>=a.arr.length)return this;const n=a.arr[e],h=(a.opt[e]||this.#r)+this.#e,t=a.arr.length-e,m=`graphs_${e}`;if(i){const r=i.getSubPadPainter(e+1);return r?(r.cleanPrimitives(!0),this.drawGraph(r,n,h,t).then(f=>(f&&(f.setSecondaryId(this,m),this.#t.push(f)),this.drawNextGraph(e+1,i)))):this}return this.#e&&(n.$num_graphs=a.arr.length),this.drawGraph(this.getPadPainter(),n,h,t).then(r=>(r&&(r.setSecondaryId(this,m),this.#t.push(r)),this.drawNextGraph(e+1)))}fillContextMenuItems(e){e.addRedrawMenu(this)}async redrawWith(e,i){if(!i){this.#i=null,this.#t=[];const r=this.getPadPainter();r?.removePrimitive(this,!0),this.#a&&r?.divide(0,0)}const a=new _(e),n=this.getObject();this.#n=a.check("3D"),this.#e="",this.#a=a.check("PADS"),["PFC","PLC","PMC"].forEach(r=>{a.check(r)&&(this.#e+=" "+r)});let h="",t=null;a.check("FB")&&this.is3d()&&(h+="FB"),A.forEach(r=>{a.check(r)&&(h+=";"+r)}),this.#r=a.remain();let m=Promise.resolve(!0);if(this.#a)m=$(this,!1).then(()=>(t=this.getPadPainter(),t.divide(n.fGraphs.arr.length,0,!0)));else if(a.check("A")||!this.getMainPainter()){const r=this.scanGraphsRange(n.fGraphs,n.fHistogram,this.getPadPainter()?.getRootPad(!0));m=this.drawAxisHist(r,h).then(f=>{f.setSecondaryId(this,"hist"),this.#i=f})}return m.then(()=>(this.addToPadPrimitives(),this.drawNextGraph(0,t))).then(()=>this.#a?this:new O(this,this.getPadPainter(),this.getObject().fFunctions,!0).drawNext(0))}static async draw(e,i,a){return new H(e,i,a).redrawWith(a,!0)}};class N extends W{async drawAxisHist(e,i){const a=this.getDrawDom();return this.is3d()?I.draw(a,e,"LEGO"+i):b.draw(a,e,i)}async drawGraph(e,i,a,n){return this.is3d()&&(a+=`pos3d_${n}`),C.draw(e,i,a)}static async draw(e,i,a){return new N(e,i,a).redrawWith(a,!0)}}export{N as TMultiGraphPainter};
