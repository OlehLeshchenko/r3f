import{aU as Ht,a9 as Tt,l as F,n as et,a6 as yt,aH as Ct,J as pt,K as wt,b2 as Xt,aF as zt,i as kt}from"./index-DAa9yKAB.js";import{T as Et}from"./THistPainter-DJAmNO-k.js";import{g as Dt}from"./func-CztLwFD8.js";const It=["LOGXY","LOGX","LOGY","LOGZ","LOGV","LOG","LOG2X","LOG2Y","LOG2","LNX","LNY","LN","GRIDXY","GRIDX","GRIDY","TICKXY","TICKX","TICKY","TICKZ","FB","GRAYSCALE"];let Kt=class St extends Et{getHisto(){const t=super.getHisto();if(t?._typename===Ht)switch(t.$getBinContent||(t.$getBinContent=t.getBinContent),this.getOptions().ProfileProj){case"B":t.getBinContent=t.getBinEntries;break;case"C=E":t.getBinContent=t.getBinError;break;case"W":t.getBinContent=function(i){return this.$getBinContent(i)*this.getBinEntries(i)};break;default:t.getBinContent=t.$getBinContent;break}return t}convertTH1K(){const t=this.getObject();if(t.fReady)return;const i=t.fArray,e=t.fEntries;t.fNcells=t.fXaxis.fNbins+2,t.fArray=new Float64Array(t.fNcells).fill(0);for(let s=0;s<t.fNIn;++s)t.Fill(i[s]);t.fReady=1,t.fEntries=e}scanContent(t){t&&!this.nbinsx&&(t=!1),this.isTH1K()&&this.convertTH1K();const i=this.getHisto(),e=this.getOptions();t||this.extractAxesProperties(1);const s=this.getSelectIndex("x","left"),l=this.getSelectIndex("x","right"),f=this.getPadPainter()?.getPadLog(e.swap_xy()?"x":"y"),u=e.Func?this.findFunction(Tt):null;if(t&&s===this.scan_xleft&&l===this.scan_xright)return;this.draw_content=!(e.Axis>0),this.scan_xleft=s,this.scan_xright=l;const b=this.isTProfile(),h=Math.min(0,s),w=Math.max(this.nbinsx,l);let r=0,d=0,n=0,o=0,E=!0,x,m={low:0,up:0};for(let _=h;_<w;++_)if(x=i.getBinContent(_+1),o+=b?i.fBinEntries[_+1]:x,!(_<s||_>=l)&&(x>0&&(d===0||x<d)&&(d=x),E&&(r=n=x,E=!1),e.Error&&(m=this.getBinErrors(i,_+1,x)),r=Math.min(r,x-m.low),n=Math.max(n,x+m.up),u)){const v=i.fXaxis.GetBinCenter(_+1),a=Dt(u,v);a!==void 0&&(n=Math.max(n,a),f&&x>0&&a>.3*x&&(d=Math.min(d,a)))}b?o+=i.fBinEntries[0]+i.fBinEntries[this.nbinsx+1]:o+=i.getBinContent(0)+i.getBinContent(this.nbinsx+1),this.stat_entries=o,this.hmin=r,this.hmax=n,(this.nbinsx===0||Math.abs(r)<1e-300&&Math.abs(n)<1e-300)&&(this.draw_content=!1);let p=!1;(this.draw_content||this.isMainPainter()&&e.Axis>0&&!e.ohmin&&!e.ohmax&&i.fMinimum===F&&i.fMaximum===F)&&(r>=n?r===0?(this.ymin=0,this.ymax=1):r<0?(this.ymin=2*r,this.ymax=0):(this.ymin=0,this.ymax=r*2):f?(this.ymin=(d||r)*.5,this.ymax=n*2*(.9/.95)):(this.ymin=r,this.ymax=n)),r=e.minimum,n=e.maximum,r===n&&r!==F&&(r<0?(r*=2,n=0):(r=0,n=2*n||1));let c=!1,k=!1;if(e.ohmin&&e.ohmax&&!this.draw_content?e.zoom_min_max?(r!==F&&r<=this.ymin&&(r=F),n!==F&&n>=this.ymax&&(n=F),p=!0):r=n=F:r!==F&&n!==F&&!this.draw_content&&(this.ymin===this.ymax||this.ymin>r||this.ymax<n)?(this.ymin=r,this.ymax=n,c=k=!0):(r!==F&&(c=!0,r<this.ymin&&(this.ymin=r),p=!0),n!==F&&(k=!0,n>this.ymax&&(this.ymax=n),p=!0)),!e.exact_values_range()&&!f){if(!c)if(e.BaseLine!==!1&&this.ymin>=0)this.ymin=0;else{const _=this.ymin>=0;this.ymin-=et.fHistTopMargin*(this.ymax-this.ymin),_&&this.ymin<0&&(this.ymin=0)}k||(this.ymax+=et.fHistTopMargin*(this.ymax-this.ymin))}t||(p&&(r!==F||n!==F)?(this.zoom_ymin=r===F?this.ymin:r,this.zoom_ymax=n===F?this.ymax:n):(delete this.zoom_ymin,delete this.zoom_ymax))}get _wheel_zoomy(){return this.getDimension()>1||!this.draw_content}getUserRanges(){const t=this.getHisto();let i=0,e=0;for(let s=0;s<t.fXaxis.fNbins;++s){const l=t.getBinContent(s+1);s===0?i=e=l:(i=Math.min(i,l),e=Math.max(e,l))}return t.fMinimum!==F&&(i=t.fMinimum),t.fMaximum!==F&&(e=t.fMaximum),e<=i&&(e=i+1),{minx:t.fXaxis.fXmin,maxx:t.fXaxis.fXmax,miny:i,maxy:e}}countStat(t,i){const e=this.isTProfile(),s=this.getHisto(),l=s.fXaxis,f=this.getSelectIndex("x","left"),u=this.getSelectIndex("x","right"),b=this.getFramePainter(),h={name:s.fName,meanx:0,meany:0,rmsx:0,rmsy:0,integral:0,entries:s.fEntries>0?s.fEntries:this.stat_entries,eff_entries:0,xmax:0,wmax:0,skewx:0,skewd:0,kurtx:0,kurtd:0},w=!b?.isAxisZoomed("x")&&Math.abs(s.fTsumw)>1e-300;let r=0,d=0,n=0,o=0,E=0,x=0,m,p,c,k=null,_=null;for(kt(t)||(t=null),m=f;m<u;++m)p=l.GetBinCoord(m+.5),!(t&&!t(p))&&(e?(c=s.fBinEntries[m+1],E+=s.fArray[m+1],x+=s.fSumw2[m+1]):c=s.getBinContent(m+1),(k===null||c>_)&&(k=p,_=c),w||(r+=c,d+=c*c,n+=c*p,o+=c*p**2));if(w&&(r=s.fTsumw,d=s.fTsumw2,n=s.fTsumwx,o=s.fTsumwx2),h.integral=r,h.eff_entries=d?r*r/d:Math.abs(r),Math.abs(r)>1e-300&&(h.meanx=n/r,h.meany=E/r,h.rmsx=Math.sqrt(Math.abs(o/r-h.meanx**2)),h.rmsy=Math.sqrt(Math.abs(x/r-h.meany**2))),k!==null&&(h.xmax=k,h.wmax=_),i){let v=0,a=0,B=0;for(m=f;m<u;++m)p=l.GetBinCoord(m+.5),!(t&&!t(p))&&(c=e?s.fBinEntries[m+1]:s.getBinContent(m+1),B+=c,v+=c*Math.pow(p-h.meanx,3),a+=c*Math.pow(p-h.meanx,4));const y=Math.pow(h.rmsx,3),S=Math.pow(h.rmsx,4);B*y&&(h.skewx=v/(B*y)),h.skewd=h.eff_entries>0?Math.sqrt(6/h.eff_entries):0,B*S&&(h.kurtx=a/(B*S)-3),h.kurtd=h.eff_entries>0?Math.sqrt(24/h.eff_entries):0}return h}fillStatistic(t,i,e){if(this.isIgnoreStatsFill())return!1;i===1&&(i=1111),e===1&&(e=111);const s=this.getHisto(),l=i%10,f=Math.floor(i/10)%10,u=Math.floor(i/100)%10,b=Math.floor(i/1e3)%10,h=Math.floor(i/1e4)%10,w=Math.floor(i/1e5)%10,r=Math.floor(i/1e6)%10,d=Math.floor(i/1e7)%10,n=Math.floor(i/1e8)%10,o=this.countStat(void 0,d>0||n>0);return t.clearPave(),l>0&&t.addText(o.name),this.isTProfile()?(f>0&&t.addText("Entries = "+t.format(o.entries,"entries")),u>0&&(t.addText("Mean = "+t.format(o.meanx)),t.addText("Mean y = "+t.format(o.meany))),b>0&&(t.addText("Std Dev = "+t.format(o.rmsx)),t.addText("Std Dev y = "+t.format(o.rmsy)))):(f>0&&t.addText("Entries = "+t.format(o.entries,"entries")),u>0&&t.addText("Mean = "+t.format(o.meanx)),b>0&&t.addText("Std Dev = "+t.format(o.rmsx)),h>0&&t.addText("Underflow = "+t.format(s.fArray.length?s.fArray[0]:0,"entries")),w>0&&t.addText("Overflow = "+t.format(s.fArray.length?s.fArray.at(-1):0,"entries")),r>0&&t.addText("Integral = "+t.format(o.integral,"entries")),d===2?t.addText(`Skewness = ${t.format(o.skewx)} #pm ${t.format(o.skewd)}`):d>0&&t.addText(`Skewness = ${t.format(o.skewx)}`),n===2?t.addText(`Kurtosis = ${t.format(o.kurtx)} #pm ${t.format(o.kurtd)}`):n>0&&t.addText(`Kurtosis = ${t.format(o.kurtx)}`)),e&&t.fillFunctionStat(this.findFunction(Tt),e,1),!0}getBarBaseline(t,i){const e=this.getOptions();let s=t.swap_xy()?0:i;return Number.isFinite(e.BaseLine)&&e.BaseLine>=t.scale_ymin&&(s=Math.round(t.gry(e.BaseLine))),s}async drawBars(t,i){const e=this.getSelectIndex("x","left",-1),s=this.getSelectIndex("x","right",1),l=this.getHisto(),f=this.getOptions(),u=l.fXaxis,b=f.Text;let h,w,r,d=f.BarStyle>10?f.BarStyle%10:0,n=Promise.resolve();d>4&&(d=4);const o=this.getBarBaseline(t,i);return b&&(h=this.getColor(l.fMarkerColor),w=-1*f.TextAngle,r=20,l.fMarkerSize!==1&&w&&(r=.02*i*l.fMarkerSize),n=this.startTextDrawingAsync(42,r,void 0,r)),n.then(()=>{let E="",x="",m="";for(let p=e;p<s;++p){const c=u.GetBinLowEdge(p+1),k=u.GetBinLowEdge(p+2);if(t.logx&&k<=0)continue;let _=Math.round(t.grx(c)),v=Math.round(t.grx(k)),a=v-_;const B=l.getBinContent(p+1);if(t.logy&&B<t.scale_ymin)continue;const y=Math.round(t.gry(B));if(_+=Math.round(l.fBarOffset/1e3*a),a=Math.round(l.fBarWidth/1e3*a),t.swap_xy()?E+=`M${o},${_}h${y-o}v${a}h${o-y}z`:E+=`M${_},${y}h${a}v${o-y}h${-a}z`,d>0&&(v=_+a,a=Math.round(a*d/10),t.swap_xy()?(x+=`M${o},${_}h${y-o}v${a}h${o-y}z`,m+=`M${o},${v}h${y-o}v${-a}h${o-y}z`):(x+=`M${_},${y}h${a}v${o-y}h${-a}z`,m+=`M${v},${y}h${-a}v${o-y}h${a}z`)),b&&B){const S=B===Math.round(B)?B.toString():yt(B,et.fPaintTextFormat);t.swap_xy()?this.drawText({align:12,x:Math.round(y+r/2),y:Math.round(_+.1),height:Math.round(a*.8),text:S,color:h,latex:0}):w?this.drawText({align:12,x:_+a/2,y:Math.round(y-2-r/5),width:0,height:0,rotate:w,text:S,color:h,latex:0}):this.drawText({align:22,x:Math.round(_+a*.1),y:Math.round(y-2-r),width:Math.round(a*.8),height:r,text:S,color:h,latex:0})}}if(E&&this.appendPath(E).call(this.fillatt.func),x&&this.appendPath(x).call(this.fillatt.func).style("fill",Ct(this.fillatt.color).brighter(.5).formatRgb()),m&&this.appendPath(m).call(this.fillatt.func).style("fill",Ct(this.fillatt.color).darker(.5).formatRgb()),b)return this.finishTextDrawing()})}drawFilledErrors(t){const i=this.getSelectIndex("x","left",0),e=this.getSelectIndex("x","right",0),s=this.getHisto(),l=[],f=[];for(let w=i;w<e;++w){const r=s.fXaxis.GetBinCoord(w+.5);if(t.logx&&r<=0)continue;const d=Math.round(t.grx(r)),n=s.getBinContent(w+1),o=this.getBinErrors(s,w+1,n);t.logy&&n-o.low<t.scale_ymin||(l.push({grx:d,gry:Math.round(t.gry(n+o.up))}),f.unshift({grx:d,gry:Math.round(t.gry(n-o.low))}))}const u=this.getOptions().ErrorKind!==4,b=pt(l,{line:u}),h=pt(f,{line:u,cmd:"L"});this.appendPath(b+h+"Z").call(this.fillatt.func)}async drawNormal(t,i,e){const s=this.getSelectIndex("x","left",-1),l=this.getSelectIndex("x","right",2),f=this.getHisto(),u=this.getOptions(),b=!this.isBatchMode()&&wt.Tooltip,h=f.fXaxis,w=!u.Zero,r=u.Error,d=u.Curve,n=u.Text,o=n&&u.TextKind==="E"&&this.isTProfile()&&f.fBinEntries,E=[];let x="",m=!1,p=u.Mark,c=u.Line,k,_,v,a,B,y,S,$,g,M,X,I,G,Z,U,rt=null,K=null,W=null,z="",tt=null,st=null,V=null,H=5,lt=!1,ht=!1,N=0,L=0,T,O,J,Y,ut,D,R,P,ft,xt,nt,gt,Mt,it,A,_t=Promise.resolve();r&&!p&&f.fMarkerStyle>1&&(p=!0),u.ErrorKind===2?this.fillatt.empty()?p=!0:rt="":r&&(c=!1,K="",tt=b?"":null,ht=!0),L=this.lineatt.width+et.fEndErrorSize,u.ErrorKind===1&&(N=Math.floor((this.lineatt.width-1)/2)),p&&(this.createAttMarker({attr:f,style:u.MarkStyle}),this.markeratt.size>0?(W="",lt=!0,this.markeratt.resetPos(),tt===null&&b&&(!this.markeratt.fill||this.markeratt.getFullSize()<7)&&(V="",H=Math.max(5,Math.round(this.markeratt.getFullSize()*.7)))):p=!1);const mt=r||p,ct=mt||n||c||d,Q=u.Hist&&(!this.lineatt.empty()||!this.fillatt.empty()),Pt=r&&f.fSumw2?.length,Ft=ct||l-s>3*i;if(!Q&&!ct)return this.removeG();if(n){if(Mt=this.getColor(f.fMarkerColor),it=-1*u.TextAngle,A=20,f.fMarkerSize!==1&&it&&(A=.02*e*f.fMarkerSize),!it&&!u.TextKind){const at=i/(l-s+1);at<3*A&&(it=270,A=Math.round(at*.7))}b&&!Q&&(st=""),_t=this.startTextDrawingAsync(42,A,void 0,A)}return _t.then(()=>{const at=C=>(Y=f.getBinContent(C+1),w&&Y===0&&(!Pt||!f.fSumw2[C+1])?!1:(D=Math.round(t.grx(h.GetBinLowEdge(C+1))),R=Math.round(t.grx(h.GetBinLowEdge(C+2))),P=Math.round((D+R)/2),_===void 0&&(_=P),T=Math.round(t.gry(Y)),r?(ut=this.getBinErrors(f,C+1,Y),O=Math.round(T-t.gry(Y+ut.up)),J=Math.round(t.gry(Y-ut.low)-T)):O=J=20,!0)),$t=()=>{let C=5;if(u.errorX>0&&(C=Math.round((R-D)*u.errorX),nt=P-C,gt=P+C,u.ErrorKind===1?K+=`M${nt+N},${T-L}v${2*L}m0,-${L}h${gt-nt-2*N}m0,-${L}v${2*L}`:K+=`M${nt+N},${T}h${gt-nt-2*N}`),u.ErrorKind===1?K+=`M${P-L},${T-O+N}h${2*L}m${-L},0v${O+J-2*N}m${-L},0h${2*L}`:K+=`M${P},${T-O+N}v${O+J-2*N}`,tt!==null){const j=Math.max(O,5),q=Math.max(J,5);tt+=`M${P-C},${T-j}h${2*C}v${j+q}h${-2*C}z`}},Bt=()=>{t.swap_xy()?(W+=this.markeratt.create(T,P),V!==null&&(V+=`M${T-H},${P-H}v${2*H}h${2*H}v${-2*H}z`)):(W+=this.markeratt.create(P,T),V!==null&&(V+=`M${P-H},${T-H}h${2*H}v${2*H}h${-2*H}z`))},ot=C=>{if(at(C)){if(n){const j=o?f.fBinEntries[C+1]:Y;if(j){const q=it?{align:12,x:P,y:Math.round(T-2-A/5),width:0,height:0,rotate:it}:{align:22,x:Math.round(D+(R-D)*.1),y:Math.round(T-2-A),width:Math.round((R-D)*.8),height:A};q.text=j===Math.round(j)?j.toString():yt(j,et.fPaintTextFormat),q.color=Mt,q.latex=0,t.swap_xy()&&(q.x=T,q.y=Math.round(P-A/2)),this.drawText(q),st!==null&&(st+=`M${D},${T-H}v${2*H}h${R-D}v${-2*H}z`)}}c?(t.swap_xy()?z+=(z?"L":"M")+`${T},${P}`:z?ft===P?z+=`v${T-xt}`:xt===T?z+=`h${P-ft}`:z+=`l${P-ft},${T-xt}`:z=`M${P},${T}`,ft=P,xt=T):d&&E.push({grx:(D+R)/2,gry:t.gry(Y)}),mt&&T>=-O&&T<=e+J&&(rt!==null&&(rt+=`M${D},${T-O}h${R-D}v${O+J+1}h${D-R}z`),W!==null&&lt&&Bt(),K!==null&&ht&&$t())}};if((lt||ht)&&(!wt.OptimizeDraw||l-s<5e4&&wt.OptimizeDraw===1)){for(G=s;G<l;++G)at(G)&&(W!==null&&Bt(),K!==null&&$t());ht=lt=!1}for(G=s;G<=l;++G)B=h.GetBinLowEdge(G+1),!(this.logx&&B<=0)&&(y=Math.round(t.grx(B)),m=G===l,m&&s<l?$=a:(S=f.getBinContent(G+1),$=Math.round(t.gry(S))),x?Ft?y===v&&!m?($<g?U=G:$>M&&(Z=G),g=Math.min(g,$),M=Math.max(M,$),a=$):(ct&&(Z===U?ot(Z):Z<U?(ot(Z),ot(U)):(ot(U),ot(Z))),Q&&(g!==M||X!==g)&&(I!==v&&(x+="h"+(v-I)),a===g?(M!==X&&(x+="v"+(M-X)),g!==M&&(x+="v"+(g-M))):(g!==X&&(x+="v"+(g-X)),M!==g&&(x+="v"+(M-g)),a!==M&&(x+="v"+(a-M))),I=v,X=a),m&&I!==y&&(x+="h"+(y-I)),Z=U=G,g=M=a=$,v=y):($!==a||m)&&(y!==v&&(x+=`h${y-v}`),$!==a&&(x+=`v${$-a}`),a=$,v=y):(Z=U=G,I=k=v=y,X=g=M=a=$,x=`M${v},${a}`));const bt=b&&this.fillatt.empty()&&Q&&!mt&&!c&&!d&&this.isUseFrame();let dt=e+3;if(!bt){const C=Math.round(t.gry(0));C<=0?dt=-3:C<e&&(dt=C)}const Gt=`L${v},${dt}H${k}Z`,vt=()=>{this.appendPath(x+(!this.fillatt.empty()||bt?Gt:"")).style("stroke-linejoin","miter").call(this.lineatt.func).call(this.fillatt.func)};if(x&&Q&&!this.fillatt.empty()&&(vt(),x=""),(mt||c||d)&&(!z&&E.length&&(t.swap_xy()&&E.forEach(C=>{[C.grx,C.gry]=[C.gry,C.grx]}),z=pt(E)),rt?this.appendPath(rt).call(this.fillatt.func):z&&!this.fillatt.empty()&&!Q&&this.appendPath(z+`L${P},${dt}H${_}Z`).call(this.fillatt.func),K&&this.appendPath(K).call(this.lineatt.func),tt&&this.appendPath(tt).style("fill","none").style("pointer-events",this.isBatchMode()?null:"visibleFill"),z&&this.appendPath(z).style("fill","none").call(this.lineatt.func),W&&this.appendPath(W).call(this.markeratt.func),V&&this.appendPath(V).style("fill","none").style("pointer-events",this.isBatchMode()?null:"visibleFill")),x&&Q&&vt(),st&&this.appendPath(st).style("fill","none").style("pointer-events",this.isBatchMode()?null:"visibleFill"),n)return this.finishTextDrawing()})}draw1DBins(){const t=this.getOptions();t.Same&&!this.isUseFrame()&&this.getPadPainter().getFrameSvg().style("display","none"),this.createHistDrawAttributes();const i=this.getHistGrFuncs(),e=i.getFrameWidth(),s=i.getFrameHeight();return!this.draw_content||e<=0||s<=0?this.removeG():(this.createG(this.isUseFrame()),t.Bar?this.drawBars(i,s).then(()=>{if(t.ErrorKind===1)return this.drawNormal(i,e,s)}):t.ErrorKind===3||t.ErrorKind===4?this.drawFilledErrors(i):this.drawNormal(i,e,s))}getBinTooltips(t){const i=[],e=this.getObjectHint(),s=this.getHistGrFuncs(),l=this.getHisto(),f=this.getOptions(),u=l.fXaxis.GetBinLowEdge(t+1),b=l.fXaxis.GetBinLowEdge(t+2),h=this.getAxisBinTip("x",l.fXaxis,t);let w=l.getBinContent(t+1);if(e&&i.push(e),f.Error||f.Mark||this.isTF1()){if(i.push(`x = ${h}`,`y = ${s.axisAsText("y",w)}`),f.Error){h[0]==="["&&i.push(`error x = ${((b-u)/2).toPrecision(4)}`);const r=this.getBinErrors(l,t+1,w);r.poisson?i.push(`error low = ${r.low.toPrecision(4)}`,`error up = ${r.up.toPrecision(4)}`):i.push(`error y = ${r.up.toPrecision(4)}`)}}else i.push(`bin = ${t+1}`,`x = ${h}`),l.$baseh&&(w-=l.$baseh.getBinContent(t+1)),w===Math.round(w)?i.push(`entries = ${w}`):i.push(`entries = ${yt(w,et.fStatFormat)}`);return i}processTooltipEvent(t){const i=this.getOptions();if(!t||!this.draw_content||!this.getG()||i.Mode3D)return this.getG()?.selectChild(".tooltip_bin").remove(),null;const e=this.getHistGrFuncs(),s=this.getHisto(),l=this.getSelectIndex("x","left",-1),f=this.getSelectIndex("x","right",2),u=this.options.Hist&&(!this.lineatt.empty()||!this.fillatt.empty());let b=e.getFrameWidth(),h=e.getFrameHeight(),w,r,d,n,o,E=2,x=l,m=f,p=t.x,c=t.y;const k=g=>{const M=s.fXaxis.GetBinLowEdge(g+1);return e.logx&&M<=0?null:e.grx(M)},_=g=>{const M=s.getBinContent(g+1);return e.logy&&M<e.scale_ymin?e.swap_xy()?-1e3:10*h:Math.round(e.gry(M))};e.swap_xy()&&([p,c,b,h]=[c,p,h,b]);const v=e.x_handle&&e.swap_xy()!==e.x_handle.reverse;for(;x<m-1;){const g=Math.round((x+m)*.5),M=k(g);M===null||M<p-.5?v?m=g:x=g:M>p+.5?v?x=g:m=g:(x++,m--)}let a=m=x;if(r=k(a),v){for(;x>l&&k(x-1)<r+2;)--x;for(;m<f&&k(m+1)>r-2;)++m}else{for(;x>l&&k(x-1)>r-2;)--x;for(;m<f&&k(m+1)<r+2;)++m}if(x<m){let g=h;for(let M=x;M<=m;M++){const X=Math.abs(_(M)-c);X<g&&(g=X,a=M)}g>h/10&&(a=Math.round(x+(m-x)/h*c)),r=k(a)}if(r=Math.round(r),d=Math.round(k(a+1)),i.Bar){const g=d-r;r+=Math.round(s.fBarOffset/1e3*g),d=r+Math.round(s.fBarWidth/1e3*g)}r>d&&([r,d]=[d,r]);const B=Math.round((r+d)/2),y=n=o=_(a);if(i.Bar)w=!0,E=0,n=this.getBarBaseline(e,h),n>o&&([n,o]=[o,n]),!t.touch&&t.nproc===1&&(c<n||c>o)&&(a=null);else if(i.Error&&i.Hist!==!0||i.Mark||i.Line||i.Curve||i.Text&&!u){w=!this.isTF1();let g=3;if(this.markeratt&&(g=Math.max(g,this.markeratt.getFullSize())),i.Error){const M=s.getBinContent(a+1),X=this.getBinErrors(s,a+1,M);n=Math.round(e.gry(M+X.up)),o=Math.round(e.gry(M-X.low)),M===0&&this.isTProfile()&&(a=null);const I=(d-r)*i.errorX;r=Math.round(B-I),d=Math.round(B+I)}d-r<2*g&&(r=B-g,d=B+g),n=Math.min(n,y-g),o=Math.max(o,y+g),!t.touch&&t.nproc===1&&(c<n||c>o)&&(a=null)}else w=t.nproc===1&&f-l<b,w&&(o=h,this.fillatt.empty()||(o=Math.min(h,Math.max(0,Math.round(e.gry(0)))),o<n&&([n,o]=[o,n])),(t.y<n||t.y>o)&&!t.touch&&(a=null));a!==null&&(a===l&&r>p+E||a===f-1&&d<p-E||p<r-E||p>d+E||!i.Zero&&s.getBinContent(a+1)===0&&s.getBinError(a+1)===0)&&(a=null);let S=this.getG().selectChild(".tooltip_bin");if(a===null||o<=0||n>=h)return S.remove(),null;const $={name:this.getObjectName(),title:s.fTitle,x:B,y,exact:!0,color1:this.lineatt?.color??"green",color2:this.fillatt?.getFillColorAlt("blue")??"blue",lines:this.getBinTooltips(a)};if(t.disabled)S.remove(),$.changed=!0;else if(w)S.empty()&&(S=this.getG().append("svg:rect").attr("class","tooltip_bin").style("pointer-events","none").call(Xt)),$.changed=S.property("current_bin")!==a,$.changed&&S.attr("x",e.swap_xy()?n:r).attr("width",e.swap_xy()?o-n:d-r).attr("y",e.swap_xy()?r:n).attr("height",e.swap_xy()?d-r:o-n).style("opacity","0.3").property("current_bin",a),$.exact=Math.abs(y-c)<=5||c>=n&&c<=o,$.menu=$.exact,$.menu_dist=Math.sqrt((B-p)**2+(y-c)**2);else{const g=this.lineatt.width+3;S.empty()&&(S=this.getG().append("svg:circle").attr("class","tooltip_bin").style("pointer-events","none").attr("r",g).call(this.lineatt.func).call(this.fillatt.func)),$.exact=Math.abs(B-t.x)<=g&&Math.abs(y-t.y)<=g,$.menu=$.exact,$.menu_dist=Math.sqrt((B-t.x)**2+(y-t.y)**2),$.changed=S.property("current_bin")!==a,$.changed&&S.attr("cx",B).attr("cy",y).property("current_bin",a)}return $.changed&&($.user_info={obj:s,name:s.fName,bin:a,cont:s.getBinContent(a+1),grx:B,gry:y}),$}fillHistContextMenu(t){t.add("Auto zoom-in",()=>this.autoZoom());const i=this.getSupportedDrawOptions();t.addDrawMenu("Draw with",i,e=>{if(e.indexOf(zt)===0)return this.showInspector(e);this.decodeOptions(e),this.getOptions().need_fillcol&&this.fillatt?.empty()&&this.fillatt.change(5,1001),this.interactiveRedraw("pad","drawopt")}),!this.hasSnapId()&&!this.isTProfile()&&!this.isTF1()&&t.addRebinMenu(e=>this.rebinHist(e))}rebinHist(t){const i=this.getHisto(),e=i.fXaxis,s=Math.floor(e.fNbins/t);if(s<2)return;const l=new Array(s+2),f=e.fXbins.length?new Array(s):null;l[0]=i.fArray[0];let u=1;for(let h=1;h<=s;++h){f&&(f[h-1]=e.fXbins[u-1]);let w=0;for(let r=0;r<t;++r)w+=i.fArray[u++];l[h]=w}f?(u<=e.fXbins.length&&(e.fXmax=e.fXbins[u-1]),e.fXbins=f):e.fXmax=e.fXmin+(e.fXmax-e.fXmin)/e.fNbins*s*t,e.fNbins=s;let b=0;for(;u<i.fArray.length;)b+=i.fArray[u++];l[s+1]=b,i.fArray=l,i.fSumw2=[],this.scanContent(),this.interactiveRedraw("pad")}autoZoom(){let t=this.getSelectIndex("x","left",-1),i=this.getSelectIndex("x","right",1);const e=i-t,s=this.getHisto();if(e===0||!s)return;let l=s.getBinContent(t+1);for(let f=t;f<i;++f)l=Math.min(l,s.getBinContent(f+1));if(!(l>0)){for(;t<i&&s.getBinContent(t+1)<=l;)++t;for(;t<i&&s.getBinContent(i)<=l;)--i;if(t===i-1&&t>2&&i<this.nbinsx-2&&(--t,++i),i-t<e&&t<i)return this.getFramePainter().zoom(s.fXaxis.GetBinLowEdge(t+1),s.fXaxis.GetBinLowEdge(i+1))}}canZoomInside(t,i,e){const s=this.getHisto();return!!(t==="x"&&s&&s.fXaxis.FindBin(e,.5)-s.fXaxis.FindBin(i,0)>1||t==="y"&&Math.abs(e-i)>Math.abs(this.ymax-this.ymin)*1e-6)}async draw2D(t){return this.clear3DScene(),this.scanContent(t==="zoom"),(this.isMainPainter()?this.drawColorPalette(!1):Promise.resolve(!0)).then(()=>this.drawAxes()).then(()=>this.draw1DBins()).then(()=>this.updateFunctions()).then(()=>this.updateHistTitle()).then(()=>(this.updateStatWebCanvas(),this.addInteractivity()))}async draw3D(t){return console.log("3D drawing is disabled, load ./hist/TH1Painter.mjs"),this.draw2D(t)}async callDrawFunc(t){const i=this.getMainPainter(),e=this.getFramePainter(),s=this.getOptions();return i!==this&&e&&e.mode3d!==s.Mode3D&&this.copyOptionsFrom(i),s.Mode3D?this.draw3D(t).catch(l=>{const f=this.getCanvPainter();return kt(f?.showConsoleError)?f.showConsoleError(l):console.error("Fail to draw histogram in 3D - back to 2D"),s.Mode3D=!1,this.draw2D(t)}):this.draw2D(t)}redraw(t){return this.callDrawFunc(t)}static async draw(t,i,e){return Et._drawHist(new St(t,i),e)}};export{It as P,Kt as T};
