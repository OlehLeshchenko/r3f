import{O as C,h as X,j as Y,k as T,l,n as $,B,o as b,D,p as N,s as L,q as _,r as S,t as E,e as z,E as y}from"./index-DAa9yKAB.js";import{T as I}from"./TH1Painter-C7yoCsum.js";import{T as R}from"./TH2Painter-Ba0oelVz.js";import{TH1Painter as F}from"./TH1Painter-BmkwKNTG.js";import{TH2Painter as W}from"./TH2Painter-yQJYXbd3.js";import"./THistPainter-DJAmNO-k.js";import"./TPavePainter-DMWA3hUD.js";import"./func-CztLwFD8.js";import"./hist3d-BC5Tno_J.js";import"./latex3d-BISPawP1.js";const A=B(16);let Z=class j extends C{#t;#i;#s;#e;constructor(r,t,a){super(r,t,a),this.#t=null,this.#i=[]}cleanup(){this.getPadPainter()?.cleanPrimitives(r=>r===this.#t||this.#i.indexOf(r)>=0),this.#t=null,this.#i=[],this.#s=void 0,super.cleanup()}buildStack(r,t){if(this.#s=null,!r.fHists)return!1;const a=r.fHists.arr.length;if(a<=0)return!1;let s=t?.findInPrimitives(void 0,X);if(s?.arr.length===a&&s?.name===r.fName)return this.#s=s,!0;s=Y(X);let n=T(r.fHists.arr[0]);s.arr.push(n);for(let e=1;e<a;++e){const i=T(r.fHists.arr[e]),f=i.fXaxis,o=n.fXaxis;let h=f.fNbins===o.fNbins&&f.fXmin===o.fXmin&&f.fXmax===o.fXmax;if(!h&&f.fNbins>0&&f.fNbins<o.fNbins&&f.fXmin===o.fXmin&&Math.abs((f.fXmax-f.fXmin)/f.fNbins-(o.fXmax-o.fXmin)/o.fNbins)<1e-4){const c=new Array(n.fNcells).fill(0);for(let m=1;m<=f.fNbins;++m)c[m]=i.fArray[m];i.fNcells=n.fNcells,Object.assign(f,o),i.fArray=c,h=!0}if(!h)return console.warn(`When drawing THStack, cannot sum-up histograms ${i.fName} and ${n.fName}`),!1;for(let c=0;c<i.fArray.length;++c)i.fArray[c]+=n.fArray[c];s.arr.push(i),n=i}return this.#s=s,!0}getMinMax(r){const t=this.getObject(),a=this.getOptions(),s=this.getPadPainter()?.getRootPad(!0),n=s?.fLogv??(a.ndim===1?s?.fLogy:s?.fLogz);let e=0,i=0;const f=(h,c)=>{const m={min:0,max:0};let d=!0,H=!0;if(h.fMinimum!==l&&(m.min=h.fMinimum,d=!1),h.fMaximum!==l&&(m.max=h.fMaximum,H=!1),!d&&!H)return m;let k=1,M=h.fXaxis.fNbins,P=1,w=1,O=!0;h.fXaxis.TestBit(y.kAxisRange)&&(k=h.fXaxis.fFirst,M=h.fXaxis.fLast),h._typename.indexOf(b)===0&&(w=h.fYaxis.fNbins,h.fYaxis.TestBit(y.kAxisRange)&&(P=h.fYaxis.fFirst,w=h.fYaxis.fLast));let u=0;for(let p=P;p<=w;++p)for(let g=k;g<=M;++g){const x=h.getBinContent(g,p);c&&(u=h.getBinError(h.getBin(g,p))),!(n&&x-u<=0)&&(d&&(O||x-u<m.min)&&(m.min=x-u),H&&(O||x+u>m.max)&&(m.max=x+u),O=!1)}return m};if(a.nostack)for(let h=0;h<t.fHists.arr.length;++h){const c=f(t.fHists.arr[h],r);h===0?(e=c.min,i=c.max):(e=Math.min(e,c.min),i=Math.max(i,c.max))}else e=f(this.#s.arr.at(0),r).min,i=f(this.#s.arr.at(-1),r).max;n?e=e>0?e*.9:i*.001:e>0&&(e=0),t.fMaximum!==l&&(i=t.fMaximum),t.fMinimum!==l&&(e=t.fMinimum),(!a.nostack||t.fMaximum===l)&&(n?e>0&&(i*=1+.2*Math.log10(i/e)):t.fMaximum===l&&(i*=1+$.fHistTopMargin)),(!a.nostack||t.fMinimum===l)&&n&&(e=e>0?e/(1+.5*Math.log10(i/e)):.001*i);const o={min:e,max:i,hopt:`;hmin:${e};hmax:${i}`};return t.fHistogram?.TestBit(A)&&(o.hopt+=";zoom_min_max"),o}getHistDrawOption(r,t){const a=this.getOptions();let s=t||r.fOption||a.hopt;if(s.toUpperCase().indexOf(a.hopt)<0&&(s+=" "+a.hopt),a.draw_errors&&!s&&(s="E"),a.zscale){const n=s.toUpperCase().indexOf("COLZ");n>=0&&(s=s.slice(0,n+3)+s.slice(n+4))}return a.pads||(s+=" same nostat"+a.auto),s}async drawNextHisto(r,t){const a=this.getObject(),s=this.getOptions(),n=s.nostack?a.fHists:this.#s,e=n?.arr?.length||0;if(r>=e)return this;const i=s.horder?r:e-r-1,f=s.nostack?`hists_${i}`:`stack_${i}`,o=n.arr[i],h=this.getHistDrawOption(o,a.fHists.opt[i]);if(t){const m=t.getSubPadPainter(r+1);return m?(m.cleanPrimitives(!0),this.drawHist(m,o,h).then(d=>(d&&(d.setSecondaryId(this,f),this.#i.push(d)),this.drawNextHisto(r+1,t)))):this}i>0&&!s.nostack&&(o.$baseh=n.arr[i-1]),s.auto&&(o.$num_histos=e);const c=this.#t?.getPadPainter()||this.getDrawDom();return this.drawHist(c,o,h).then(m=>(m.setSecondaryId(this,f),this.#i.push(m),this.drawNextHisto(r+1,t)))}decodeOptions(r){const t=this.setOptions({ndim:1,nostack:!1,same:!1,horder:!0,has_errors:!1,draw_errors:!1,hopt:"",auto:""}),a=this.getObject();(a.fHistogram||a.fHists?.arr[0]||this.#s?.arr[0])?._typename.indexOf(b)===0&&(t.ndim=2),t.ndim===2&&!r&&(r="lego1"),t.nostack||a.fHists?.arr.forEach(i=>{const f=i.fSumw2?.length??0;for(let o=0;o<f;++o)if(i.fSumw2[o]>0){t.has_errors=!0;break}}),t.nhist=a.fHists?.arr?.length??1;const n=new D(r);t.nostack=n.check("NOSTACK"),n.check("STACK")&&(t.nostack=!1),t.same=n.check("SAME"),n.check("NOCLEAR"),["PFC","PLC","PMC"].forEach(i=>{n.check(i)&&(t.auto+=" "+i)}),t.pads=n.check("PADS"),t.pads&&(t.nostack=!0),t.hopt=n.remain().trim();const e=n.check("LEGO");t.errors=n.check("E"),t.zscale=n.check("COLZ"),!t.nostack&&t.has_errors&&!e&&!n.check("HIST")&&t.hopt.indexOf("E")<0&&(t.draw_errors=!0),t.horder=t.nostack||e}createHistogram(r){const t=this.getOptions(),a=r.fHists,s=a?.arr.length??0;if(!s){const i=N(S,100);return L(i,r.fTitle),i.fBits|=_,i}const n=a.arr[0],e=N(t.ndim===1?S:E,n.fXaxis.fNbins,n.fYaxis.fNbins);e.fName="axis_hist",e.fBits|=_,Object.assign(e.fXaxis,n.fXaxis),t.ndim===2&&Object.assign(e.fYaxis,n.fYaxis);for(let i=1;i<s;++i){const f=a.arr[i];e.fXaxis.fLabels||(e.fXaxis.fXmin=Math.min(e.fXaxis.fXmin,f.fXaxis.fXmin),e.fXaxis.fXmax=Math.max(e.fXaxis.fXmax,f.fXaxis.fXmax)),t.ndim===2&&!e.fYaxis.fLabels&&(e.fYaxis.fXmin=Math.min(e.fYaxis.fXmin,f.fYaxis.fXmin),e.fYaxis.fXmax=Math.max(e.fYaxis.fXmax,f.fYaxis.fXmax))}return e.fTitle=r.fTitle,e}updateObject(r){if(!this.matchObjectType(r))return!1;const t=this.getObject(),a=this.getPadPainter(),s=this.getOptions();if(t.fHists=r.fHists,t.fTitle=r.fTitle,t.fMinimum=r.fMinimum,t.fMaximum=r.fMaximum,s.nostack||(s.nostack=!this.buildStack(t,a)),this.#t){let i=r.fHistogram;i||(i=t.fHistogram=this.createHistogram(t));const f=this.getMinMax(s.errors||s.draw_errors);this.#t.options.hmin=f.min,this.#t.options.hmax=f.max,this.#t._checked_zooming=!1,s.ndim===1?(this.#t.ymin=f.min,this.#t.ymax=f.max):(this.#t.zmin=f.min,this.#t.zmax=f.max),this.#t.updateObject(i),this.#t.options.zoom_min_max=i.TestBit(A)}const n=s.nostack?t.fHists:this.#s,e=n?.arr?.length??0;if(e!==this.#i.length)this.#e=1,a?.cleanPrimitives(i=>this.#i.indexOf(i)>=0),this.#i=[];else{this.#e=2;for(let i=0;i<e;++i){const f=s.horder?i:e-i-1,o=n.arr[f];this.#i[i].updateObject(o,this.getHistDrawOption(o,t.fHists.opt[f]))}}return!0}redraw(r){if(!this.#e)return;const t=this.#e===1;this.#e=void 0;let a=Promise.resolve(this);const s=this.getOptions();if(this.#t){const n=this.getMinMax(s.errors||s.draw_errors);this.#t.decodeOptions(s.hopt+n.hopt),a=this.#t.redraw(r)}return a.then(()=>{if(t)return this.drawNextHisto(0,s.pads?this.getPadPainter():null);const n=e=>e>=this.#i.length?this:this.#i[e].redraw(r).then(()=>n(e+1));return n(0)})}fillContextMenuItems(r){const t=this.getOptions();r.addRedrawMenu(this),t.pads||r.addchk(t.draw_errors,"Draw errors",a=>{t.draw_errors=a;const s=this.getObject(),n=t.nostack?s.fHists:this.#s,e=n?.arr?.length??0;for(let i=0;i<e;++i){const f=t.horder?i:e-i-1,o=n.arr[f];this.#i[i].decodeOptions(this.getHistDrawOption(o,s.fHists.opt[f]))}this.redrawPad()},"Change draw erros in the stack")}drawHist(r,t,a){return(this.getOptions().ndim===1?I.draw:R.draw)(r,t,a)}accessMM(r,t){const a=r?"fMinimum":"fMaximum",s=this.getObject();if(t===void 0)return s[a];this.#e=2,s[a]=t,this.interactiveRedraw("pad",r?`exec:SetMinimum(${t})`:`exec:SetMaximum(${t})`)}async redrawWith(r,t){const a=this.getPadPainter(),s=this.getOptions();!t&&a&&(this.#t=null,this.#i=[],s.pads&&a.divide(0,0),a.removePrimitive(this,!0)),this.decodeOptions(r);const n=this.getObject();let e=Promise.resolve(this),i=null;if(s.pads)e=z(this,!1).then(()=>(i=this.getPadPainter(),i.divide(s.nhist,0,!0)));else if(s.nostack||(s.nostack=!this.buildStack(n,a)),!s.same&&n.fHists?.arr.length){n.fHistogram||(n.fHistogram=this.createHistogram(n));const f=this.getMinMax(s.errors||s.draw_errors);e=this.drawHist(this.getDrawDom(),n.fHistogram,s.hopt+f.hopt).then(o=>{this.#t=o,o.$stack_hist=!0,o.setSecondaryId(this,"hist")})}return e.then(()=>this.drawNextHisto(0,i)).then(()=>(s.pads||this.addToPadPrimitives(),this))}static async draw(r,t,a){return!t.fHists||!t.fHists.arr?null:new j(r,t,a).redrawWith(a,!0)}};class v extends Z{drawHist(r,t,a){return(this.getOptions().ndim===1?F.draw:W.draw)(r,t,a)}static async draw(r,t,a){return!t.fHists||!t.fHists.arr?null:new v(r,t,a).redrawWith(a,!0)}}export{v as THStackPainter};
