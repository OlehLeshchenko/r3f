import{O as m,e as C}from"./index-DAa9yKAB.js";class g{static CONSTANTS={DELAY:0,OFFSET_X:10,OFFSET_Y:-10,PADDING:8,BORDER_RADIUS:4};constructor(e){this.painter=e,this.tooltip=null,this.content="",this.x=0,this.y=0}cleanup(){this.tooltip!==null&&(document.body.removeChild(this.tooltip),this.tooltip=null)}createTooltip(){this.tooltip||(this.tooltip=document.createElement("div"),this.tooltip.style.cssText=`
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: ${g.CONSTANTS.PADDING}px;
            border-radius: ${g.CONSTANTS.BORDER_RADIUS}px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 200px;
            word-wrap: break-word;
        `,document.body.appendChild(this.tooltip))}showTooltip(){this.tooltip||this.createTooltip(),this.tooltip.innerHTML=this.content,this.tooltip.style.left=this.x+g.CONSTANTS.OFFSET_X+"px",this.tooltip.style.top=this.y+g.CONSTANTS.OFFSET_Y+"px",this.tooltip.style.opacity="1"}hideTooltip(){this.tooltip&&(this.tooltip.style.opacity="0")}generateTooltipContent(e){const t=e.fNChildren===0;let i=e.fName.length>0?`<strong>${e.fName}</strong><br>`:"";i+=`<i>${t?"Column":"Field"}</i><br>`,i+=`Size: ${this.painter.getDataStr(e.fSize)}<br>`,t&&e.fType!==void 0&&(i+=`Type: ${e.fType}<br>`),t||(i+=`Children: ${e.fNChildren}<br>`);const o=this.painter.getObject();if(o.fNodes&&o.fNodes.length>0){const n=o.fNodes[0].fSize,s=(e.fSize/n*100).toFixed(2);i+=`Disk Usage: ${s}%`}return i}}function b(O){const e=14695981039346656037n,t=1099511628211n;let i=e;for(let o=0;o<O.length;++o){const n=BigInt(O.charCodeAt(o)&255);i^=n,i*=t}return i}class l extends m{static CONSTANTS={STROKE_WIDTH:.15,STROKE_COLOR:"black",COLOR_HOVER_BOOST:10,DATA_UNITS:["B","KB","MB","GB","TB","PB","EB"],MAIN_TREEMAP:{LEFT:.025,BOTTOM:.05,RIGHT:.825,TOP:.9},LEGEND:{START_Y:.835,ITEM_HEIGHT:.05,BOX_WIDTH:.05,TEXT_OFFSET_X:.01,TEXT_OFFSET_Y:.01,TEXT_LINE_SPACING:.015,MAX_ITEMS:10},TEXT:{SIZE_VW:.6,MIN_RECT_WIDTH:.025,MIN_RECT_HEIGHT:.05,PADDING:10,LEAF_OFFSET_Y:.015},INDENT:.005,LEGEND_INDENT_MULTIPLIER:4};constructor(e,t,i){super(e,t,i),this.tooltip=new g(this),this.rootIndex=0,this.parentIndices=[]}cleanup(){this._frame_hidden&&(delete this._frame_hidden,this.getPadPainter()?.getFrameSvg().style("display",null)),this.tooltip.cleanup(),super.cleanup()}appendRect(e,t,i,o=l.CONSTANTS.STROKE_COLOR,n=l.CONSTANTS.STROKE_WIDTH,s=null){const r=this.getG().append("rect").attr("x",this.axisToSvg("x",e.x,this.isndc)).attr("y",this.axisToSvg("y",e.y,this.isndc)).attr("width",`${Math.abs(t.x-e.x)*100}%`).attr("height",`${Math.abs(t.y-e.y)*100}%`).attr("fill",i).attr("stroke",o).attr("stroke-width",n).attr("pointer-events","fill");return s&&(r.datum(s),this.attachPointerEventsTreeMap(r,s)),r}appendText(e,t,i,o,n="start"){return this.getG().append("text").attr("x",this.axisToSvg("x",t.x,this.isndc)).attr("y",this.axisToSvg("y",t.y,this.isndc)).attr("font-size",`${i}vw`).attr("fill",o).attr("text-anchor",n).attr("pointer-events","none").text(e)}getRgbList(e){return e.slice(4,-1).split(",").map(t=>parseInt(t))}toRgbStr(e){return`rgb(${e.join()})`}attachPointerEventsTreeMap(e,t){const i=e.attr("fill"),o=this.toRgbStr(this.getRgbList(i).map(h=>Math.min(h+l.CONSTANTS.COLOR_HOVER_BOOST,255))),n=()=>{e.attr("fill",o),this.tooltip.content=this.tooltip.generateTooltipContent(t),this.tooltip.x=0,this.tooltip.y=0},s=()=>{e.attr("fill",i),this.tooltip.hideTooltip()},r=h=>{this.tooltip.x=h.pageX,this.tooltip.y=h.pageY,this.tooltip.showTooltip()},c=()=>{const h=this.getObject(),a=h.fNodes.findIndex(T=>T===t);if(a===this.rootIndex)this.rootIndex=this.parentIndices[a];else{let T=a;for(;this.parentIndices[T]!==this.rootIndex;)T=this.parentIndices[T];this.rootIndex=T,h.fNodes[T].fNChildren===0&&(this.rootIndex=this.parentIndices[a])}this.redraw()};this.attachPointerEvents(e,{mouseenter:n,mouseleave:s,mousemove:r,click:c})}attachPointerEventsLegend(e,t){const i=this.getG().selectAll("rect"),o=()=>{i.filter(s=>s!==void 0&&s.fType!==t).attr("opacity","0.5")},n=()=>{i.attr("opacity","1")};this.attachPointerEvents(e,{mouseenter:o,mouseleave:n,mousemove:()=>{},click:()=>{}})}attachPointerEvents(e,t){for(const[i,o]of Object.entries(t))e.on(i,o)}computeColor(e){const t=Number(b(String(e))&0xFFFFFFFFn),i=t>>16&255,o=t>>8&255,n=t&255;return this.toRgbStr([i,o,n])}getDataStr(e){const t=l.CONSTANTS.DATA_UNITS,i=Math.floor(Math.log10(e)/3);return`${(e/Math.pow(1e3,i)).toFixed(2)}${t[i]}`}computeWorstRatio(e,t,i,o,n){if(e.length===0)return 0;const s=e.reduce((c,h)=>c+h.fSize,0);if(s===0)return 0;let r=0;for(const c of e){const h=n?c.fSize*t*o/(s*s*i):c.fSize*i*o/(s*s*t),a=Math.max(h,1/h);a>r&&(r=a)}return r}squarifyChildren(e,t,i,o){const n=t.topRight.x-t.bottomLeft.x,s=t.topRight.y-t.bottomLeft.y,r=[...e].sort((a,T)=>T.fSize-a.fSize),c=[],h={...t.bottomLeft};for(;r.length>0;){const a=[];let T=1/0;const x=t.topRight.x-h.x,N=t.topRight.y-h.y;if(x<=0||N<=0)break;for(;r.length>0;){a.push(r.shift());const S=this.computeWorstRatio(a,x,N,o,i);if(S>T){r.unshift(a.pop());break}T=S}const f=a.reduce((S,E)=>S+E.fSize,0);if(f===0)continue;const d=i?f/o*s:f/o*n;let p=0;for(const S of a){const E=S.fSize/f*(i?n:s),u=i?{x:h.x+p,y:h.y}:{x:h.x,y:h.y+p},I=i?{x:h.x+p+E,y:h.y+d}:{x:h.x+d,y:h.y+p+E};c.push({node:S,rect:{bottomLeft:u,topRight:I}}),p+=E}i?h.y+=d:h.x+=d}return c}drawLegend(){const e=this.getObject(),t={};let i=[this.rootIndex];for(;i.length>0;){const s=e.fNodes[i.pop()];s.fNChildren===0&&(t[s.fType]=(t[s.fType]||0)+s.fSize),i=i.concat(Array.from({length:s.fNChildren},(r,c)=>c+s.fChildrenIdx))}const o=Object.entries(t).sort((s,r)=>r[1]-s[1]).slice(0,l.CONSTANTS.LEGEND.MAX_ITEMS).filter(([,s])=>s>0),n=l.CONSTANTS.LEGEND;o.forEach(([s,r],c)=>{const h=n.START_Y-c*n.ITEM_HEIGHT,a=n.START_Y+n.ITEM_HEIGHT+n.TEXT_OFFSET_X,T=l.CONSTANTS.TEXT.SIZE_VW,x=this.appendRect({x:n.START_Y,y:h},{x:n.START_Y+n.ITEM_HEIGHT,y:h-n.ITEM_HEIGHT},this.computeColor(s));this.attachPointerEventsLegend(x,s);const N=`${(r/e.fNodes[this.rootIndex].fSize*100).toFixed(2)}%`,f=`(${this.getDataStr(r)} / ${this.getDataStr(e.fNodes[this.rootIndex].fSize)})`;[s,f,N].forEach((d,p)=>this.appendText(d,{x:a,y:h-n.TEXT_OFFSET_Y-n.TEXT_LINE_SPACING*p},T,"black"))})}trimText(e,t){const i=e.node();let o=i.textContent;const n=Math.abs(this.axisToSvg("x",t.topRight.x,this.isndc)-this.axisToSvg("x",t.bottomLeft.x,this.isndc))-l.CONSTANTS.TEXT.PADDING;for(;i.getComputedTextLength&&i.getComputedTextLength()>n&&o.length>0;)o=o.slice(0,-1),i.textContent=o+"â€¦";return o}drawTreeMap(e,t,i=0){const o=e.fNChildren===0,n=o?this.computeColor(e.fType):"rgb(100,100,100)";this.appendRect({x:t.bottomLeft.x,y:t.topRight.y},{x:t.topRight.x,y:t.bottomLeft.y},n,l.CONSTANTS.STROKE_COLOR,l.CONSTANTS.STROKE_WIDTH,e);const s=t.topRight.x-t.bottomLeft.x,r=t.topRight.y-t.bottomLeft.y,c=`${e.fName} (${this.getDataStr(e.fSize)})`,h=l.CONSTANTS.TEXT,a=s<=h.MIN_RECT_WIDTH||r<=h.MIN_RECT_HEIGHT?0:h.SIZE_VW;if(a>0){const T=this.appendText(c,{x:t.bottomLeft.x+(o?s/2:l.CONSTANTS.INDENT),y:o?(t.bottomLeft.y+t.topRight.y)/2:t.topRight.y-h.LEAF_OFFSET_Y},a,"white",o?"middle":"start");T.textContent=this.trimText(T,t)}if(!o&&e.fNChildren>0){const T=this.getObject(),x=T.fNodes.slice(e.fChildrenIdx,e.fChildrenIdx+e.fNChildren),N=x.reduce((f,d)=>f+d.fSize,0);if(N>0){const f=l.CONSTANTS.INDENT,d={bottomLeft:{x:t.bottomLeft.x+f,y:t.bottomLeft.y+f},topRight:{x:t.topRight.x-f,y:t.topRight.y-f*l.CONSTANTS.LEGEND_INDENT_MULTIPLIER}},p=d.topRight.x-d.bottomLeft.x,S=d.topRight.y-d.bottomLeft.y,E=p>S;this.squarifyChildren(x,d,E,N).forEach(({node:I,rect:y})=>{this.drawTreeMap(I,y,i+1)})}}}createParentIndices(){const e=this.getObject();this.parentIndices=new Array(e.fNodes.length).fill(0),e.fNodes.forEach((t,i)=>{for(let o=t.fChildrenIdx;o<t.fChildrenIdx+t.fNChildren;o++)this.parentIndices[o]=i})}getDirectory(){const e=this.getObject();let t="",i=this.rootIndex;for(;i!==0;)t=e.fNodes[i].fName+"/"+t,i=this.parentIndices[i];return t}redraw(){const e=this.getPadPainter().getFrameSvg();e.empty()||(e.style("display","none"),this._frame_hidden=!0);const t=this.getObject();if(this.createG(),this.isndc=!0,t.fNodes&&t.fNodes.length>0){this.createParentIndices();const i=l.CONSTANTS.MAIN_TREEMAP;this.drawTreeMap(t.fNodes[this.rootIndex],{bottomLeft:{x:i.LEFT,y:i.BOTTOM},topRight:{x:i.RIGHT,y:i.TOP}}),this.drawLegend(),this.appendText(this.getDirectory(),{x:l.CONSTANTS.MAIN_TREEMAP.LEFT,y:l.CONSTANTS.MAIN_TREEMAP.TOP+.01},l.CONSTANTS.TEXT.SIZE_VW,"black")}return this}static async draw(e,t,i){const o=new l(e,t,i);return C(o,!1).then(()=>o.redraw())}}export{l as RTreeMapPainter};
