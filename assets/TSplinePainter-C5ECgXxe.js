import{O as d,n as p,p as y,q as M,a6 as x,J as X,D as P,ac as _}from"./index-DAa9yKAB.js";import{TH1Painter as O}from"./TH1Painter-BmkwKNTG.js";import"./hist3d-BC5Tno_J.js";import"./latex3d-BISPawP1.js";import"./THistPainter-DJAmNO-k.js";import"./TPavePainter-DMWA3hUD.js";import"./TH2Painter-Ba0oelVz.js";import"./TH1Painter-C7yoCsum.js";import"./func-CztLwFD8.js";class g extends d{#t;updateObject(t,i){const e=this.getObject();return e._typename!==t._typename?!1:(e!==t&&Object.assign(e,t),i!==void 0&&this.decodeOptions(i),!0)}eval(t,i){const e=i-t.fX;return t._typename==="TSplinePoly3"?t.fY+e*(t.fB+e*(t.fC+e*t.fD)):t._typename==="TSplinePoly5"?t.fY+e*(t.fB+e*(t.fC+e*(t.fD+e*(t.fE+e*t.fF)))):t.fY+e}findX(t){const i=this.getObject();let e=0,s=i.fNp-1;if(t<=i.fXmin)return e;if(t>=i.fXmax)return s;if(i.fKstep)e=Math.round((t-i.fXmin)/i.fDelta),t<i.fPoly[e].fX?e=Math.max(e-1,0):e<s&&t>i.fPoly[e+1].fX&&++e;else for(;s-e>1;){const r=Math.round((e+s)/2);t>i.fPoly[r].fX?e=r:s=r}return e}createDummyHisto(){const t=this.getObject();let i=0,e=1,s=0,r=1;t.fPoly&&(i=e=t.fPoly[0].fX,s=r=t.fPoly[0].fY,t.fPoly.forEach(f=>{i=Math.min(f.fX,i),e=Math.max(f.fX,e),s=Math.min(f.fY,s),r=Math.max(f.fY,r)}),r>0&&(r*=1+p.fHistTopMargin),s<0&&(s*=1+p.fHistTopMargin));const a=y(_,10);return a.fName=t.fName+"_hist",a.fTitle=t.fTitle,a.fBits|=M,a.fXaxis.fXmin=i,a.fXaxis.fXmax=e,a.fYaxis.fXmin=s,a.fYaxis.fXmax=r,a.fMinimum=s,a.fMaximum=r,a}processTooltipEvent(t){const i=this.getObject(),e=this.getOptions(),s=this.getFramePainter()?.getGrFuncs(e.second_x,e.second_y);let r=!1,a,f,n=null,l=0;t===null||!i||!s?r=!0:(a=s.revertAxis("x",t.x),l=this.findX(a),n=i.fPoly[l],f=this.eval(n,a),l<i.fN-1&&Math.abs(i.fPoly[l+1].fX-a)<Math.abs(a-n.fX)&&(n=i.fPoly[++l]),Math.abs(s.grx(n.fX)-t.x)<.5*this.#t?(a=n.fX,f=n.fY):(n=null,(a<i.fXmin||a>i.fXmax)&&(r=!0)));let c=this.getG()?.selectChild(".tooltip_bin");const h=this.lineatt.width+3;if(r||!this.getG())return c?.remove(),null;c.empty()&&(c=this.getG().append("svg:circle").attr("class","tooltip_bin").style("pointer-events","none").attr("r",h).style("fill","none").call(this.lineatt.func));const o={name:this.getObject().fName,title:this.getObject().fTitle,x:s.grx(a),y:s.gry(f),color1:this.lineatt.color,lines:[],exact:n!==null||Math.abs(s.gry(f)-t.y)<h};o.changed=c.property("current_xx")!==a,o.menu=o.exact,o.menu_dist=Math.sqrt((o.x-t.x)**2+(o.y-t.y)**2),o.changed&&c.attr("cx",Math.round(o.x)).attr("cy",Math.round(o.y)).property("current_xx",a);const m=this.getObjectHint();return m&&o.lines.push(m),o.lines.push(`x = ${s.axisAsText("x",a)}`,`y = ${s.axisAsText("y",f)}`),n!==null&&(o.lines.push(`knot = ${l}`,`B = ${x(n.fB,p.fStatFormat)}`,`C = ${x(n.fC,p.fStatFormat)}`,`D = ${x(n.fD,p.fStatFormat)}`),n.fE!==void 0&&n.fF!==void 0&&o.lines.push(`E = ${x(n.fE,p.fStatFormat)}`,`F = ${x(n.fF,p.fStatFormat)}`)),o}redraw(){const t=this.getObject(),i=this.getOptions(),e=this.getFramePainter().getGrFuncs(i.second_x,i.second_y),s=e.getFrameWidth(),r=e.getFrameHeight(),a=this.createG(!0);if(this.#t=5,this.createAttLine({attr:t}),i.Line||i.Curve){const f=Math.max(10,t.fNpx),n=[];let l=Math.max(e.scale_xmin,t.fXmin),c=Math.min(e.scale_xmax,t.fXmax),h=this.findX(l);e.logx&&(l=Math.log(l),c=Math.log(c));for(let o=0;o<f;++o){let m=l+(c-l)/f*(o-1);for(e.logx&&(m=Math.exp(m));h<t.fNp-1&&m>t.fPoly[h+1].fX;)++h;const u=this.eval(t.fPoly[h],m);n.push({x:m,y:u,grx:e.grx(m),gry:e.gry(u)})}a.append("svg:path").attr("class","line").attr("d",X(n)).style("fill","none").call(this.lineatt.func)}if(i.Mark){this.createAttMarker({attr:t}),this.markeratt.resetPos(),this.#t=this.markeratt.getFullSize();let f="";for(let n=0;n<t.fPoly.length;n++){const l=t.fPoly[n],c=e.grx(l.fX);if(c>-this.#t&&c<s+this.#t){const h=e.gry(l.fY);h>-this.#t&&h<r+this.#t&&(f+=this.markeratt.create(c,h))}}f&&a.append("svg:path").attr("d",f).call(this.markeratt.func)}}canZoomInside(t){return t!=="x"?!1:!!this.getObject()}decodeOptions(t){const i=new P(t),e=this.setOptions({Same:i.check("SAME"),Line:i.check("L"),Curve:i.check("C"),Mark:i.check("P"),Hopt:"",second_x:!1,second_y:!1});!e.Line&&!e.Curve&&!e.Mark&&(e.Curve=!0),i.check("X+")&&(e.Hopt+="X+",e.second_x=!!this.getMainPainter()),i.check("Y+")&&(e.Hopt+="Y+",e.second_y=!!this.getMainPainter()),this.storeDrawOpt(t)}static async draw(t,i,e){const s=new g(t,i);s.decodeOptions(e);const r=!s.getMainPainter();let a=Promise.resolve();if(r||s.options.second_x||s.options.second_y){if(s.options.Same&&r)return console.warn("TSpline painter requires histogram to be drawn"),null;const f=s.createDummyHisto();a=O.draw(t,f,s.options.Hopt)}return a.then(()=>(s.addToPadPrimitives(),s.redraw(),s))}}export{g as TSplinePainter};
